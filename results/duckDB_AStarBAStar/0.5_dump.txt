seed = 1736846041986500130
2,0.5,5,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 0);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
2,0.5,4,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 0);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
2,0.5,4,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 0);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
2,0.5,4,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 0);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
2,0.5,3,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 1);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
2,0.5,3,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 1);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
2,0.5,3,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 1);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
2,0.5,3,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 1);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
2,0.5,5,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (1, 0);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
2,0.5,5,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (1, 0);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
2,0.5,5,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (1, 0);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
2,0.5,5,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (1, 0);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
2,0.5,7,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
2,0.5,8,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
2,0.5,7,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
2,0.5,7,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
2,0.5,4,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
2,0.5,4,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
2,0.5,4,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
2,0.5,3,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
3,0.5,3,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
3,0.5,4,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
3,0.5,4,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
3,0.5,3,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
3,0.5,4,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
3,0.5,4,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
3,0.5,4,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
3,0.5,4,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
3,0.5,7,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (2, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
3,0.5,7,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (2, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
3,0.5,7,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (2, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
3,0.5,7,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (2, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
3,0.5,13,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
3,0.5,12,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
3,0.5,12,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
3,0.5,12,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
3,0.5,4,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
3,0.5,4,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
3,0.5,4,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
3,0.5,4,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
4,0.5,6,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 1);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
4,0.5,6,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 1);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
4,0.5,6,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 1);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
4,0.5,6,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 1);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
4,0.5,15,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
4,0.5,14,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
4,0.5,14,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
4,0.5,14,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
4,0.5,19,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
4,0.5,18,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
4,0.5,18,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
4,0.5,18,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
4,0.5,14,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
4,0.5,13,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
4,0.5,13,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
4,0.5,13,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
4,0.5,4,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
4,0.5,4,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
4,0.5,4,true,10:14:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
4,0.5,4,true,10:14:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
5,0.5,19,true,10:14:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
5,0.5,19,true,10:14:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
5,0.5,19,true,10:14:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
5,0.5,18,true,10:14:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
5,0.5,14,true,10:14:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
5,0.5,14,true,10:14:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
5,0.5,14,true,10:14:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
5,0.5,15,true,10:14:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
5,0.5,7,true,10:14:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
5,0.5,7,true,10:14:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
5,0.5,7,true,10:14:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
5,0.5,7,true,10:14:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
5,0.5,6,true,10:14:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
5,0.5,6,true,10:14:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
5,0.5,6,true,10:14:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
5,0.5,6,true,10:14:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
5,0.5,15,true,10:14:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (4, 4);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
5,0.5,15,true,10:14:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (4, 4);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
5,0.5,15,true,10:14:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (4, 4);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
5,0.5,15,true,10:14:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (4, 4);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
6,0.5,170,true,10:14:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (5, 1);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
6,0.5,168,true,10:14:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (5, 1);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
6,0.5,169,true,10:14:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (5, 1);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
6,0.5,169,true,10:14:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (5, 1);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
6,0.5,22,true,10:14:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
6,0.5,22,true,10:14:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
6,0.5,23,true,10:14:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
6,0.5,22,true,10:14:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
6,0.5,17,true,10:14:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
6,0.5,16,true,10:14:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
6,0.5,16,true,10:14:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
6,0.5,17,true,10:14:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
6,0.5,18,true,10:14:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
6,0.5,17,true,10:14:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
6,0.5,17,true,10:14:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
6,0.5,17,true,10:14:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
6,0.5,15,true,10:14:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
6,0.5,16,true,10:14:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
6,0.5,17,true,10:14:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
6,0.5,16,true,10:14:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
7,0.5,19,true,10:14:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
7,0.5,18,true,10:14:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
7,0.5,20,true,10:14:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
7,0.5,20,true,10:14:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
7,0.5,5184,true,10:14:18
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
7,0.5,5083,true,10:14:23
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
7,0.5,5106,true,10:14:28
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
7,0.5,5098,true,10:14:33
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
7,0.5,14,true,10:14:33
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 6);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
7,0.5,14,true,10:14:33
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 6);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
7,0.5,15,true,10:14:33
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 6);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
7,0.5,14,true,10:14:33
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 6);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
7,0.5,16,true,10:14:33
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
7,0.5,15,true,10:14:33
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
7,0.5,15,true,10:14:33
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
7,0.5,16,true,10:14:33
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
7,0.5,16,true,10:14:33
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 6);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
7,0.5,16,true,10:14:33
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 6);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
7,0.5,16,true,10:14:33
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 6);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
7,0.5,16,true,10:14:33
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 6);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
8,0.5,19,true,10:14:33
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 7);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
8,0.5,19,true,10:14:33
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 7);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
8,0.5,19,true,10:14:33
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 7);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
8,0.5,21,true,10:14:33
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 7);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
8,0.5,21,true,10:14:34
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 5);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
8,0.5,21,true,10:14:34
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 5);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
8,0.5,23,true,10:14:34
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 5);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
8,0.5,21,true,10:14:34
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 5);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
8,0.5,128678,true,10:18:51
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 7);


explain analyze WITH RECURSIVE a_star AS (
    SELECT s, t, 0 AS depth, ARRAY[s, t] AS path, ARRAY[s || '.'|| t] AS edges FROM A
    UNION ALL
    SELECT A.s::VARCHAR, A.t::VARCHAR, a_star.depth + 1, a_star.path || ARRAY[A.t], CONCAT(a_star.edges, ARRAY[A.s || '.' || A.t])
    FROM A, a_star
    WHERE A.s = a_star.t
    AND NOT A.s || '.' || A.t IN (SELECT UNNEST(a_star.edges))
	)
	SELECT A1.s, A2.t 
	FROM a_star A1, a_star A2, B
	WHERE A1.t = B.s AND B.t = A2.s;
------
