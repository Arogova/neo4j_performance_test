seed = 1737974287409192472
2,0.9,5,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.9,5,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.9,5,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.9,5,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.9,9,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.9,8,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.9,9,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.9,8,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.9,8,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.9,9,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.9,9,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.9,9,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.9,8,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.9,9,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.9,9,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.9,9,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.9,6,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.9,6,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.9,6,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.9,6,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.9,11,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.9,10,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.9,10,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.9,11,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.9,13,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.9,13,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.9,13,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.9,13,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.9,7,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.9,7,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.9,8,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.9,7,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.9,11,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.9,12,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.9,11,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.9,12,true,11:38:12
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.9,12,true,11:38:13
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.9,13,true,11:38:13
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.9,12,true,11:38:13
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.9,12,true,11:38:13
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.9,12,true,11:38:13
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.9,11,true,11:38:13
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.9,12,true,11:38:13
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.9,11,true,11:38:13
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.9,22,true,11:38:13
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.9,21,true,11:38:13
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.9,24,true,11:38:13
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.9,22,true,11:38:13
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.9,18,true,11:38:13
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.9,19,true,11:38:13
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.9,18,true,11:38:13
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.9,19,true,11:38:13
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.9,41,true,11:38:13
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.9,41,true,11:38:13
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.9,39,true,11:38:13
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.9,40,true,11:38:13
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.9,14,true,11:38:13
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.9,11,true,11:38:13
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.9,10,true,11:38:13
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.9,12,true,11:38:13
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.9,3028,true,11:38:19
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.9,2997,true,11:38:22
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.9,3034,true,11:38:25
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.9,3041,true,11:38:28
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.9,52,true,11:38:29
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.9,52,true,11:38:29
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.9,52,true,11:38:29
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.9,52,true,11:38:29
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.9,60,true,11:38:29
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.9,60,true,11:38:29
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.9,61,true,11:38:29
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.9,60,true,11:38:29
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.9,16,true,11:38:29
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.9,16,true,11:38:29
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.9,17,true,11:38:29
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.9,16,true,11:38:29
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.9,4047,true,11:38:37
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.9,3986,true,11:38:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.9,3993,true,11:38:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.9,3982,true,11:38:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.9,13594,true,11:39:16
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.9,13623,true,11:39:30
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.9,13460,true,11:39:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.9,13529,true,11:39:57
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.9,28063,true,11:40:53
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.9,27917,true,11:41:21
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.9,27789,true,11:41:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.9,27878,true,11:42:17
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.9,120,true,11:42:17
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.9,118,true,11:42:17
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.9,118,true,11:42:17
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.9,117,true,11:42:17
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE OR REPLACE SEQUENCE serial START 1;
CREATE TABLE A (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE B (id INTEGER DEFAULT nextval('serial'), s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s::VARCHAR, A.t::VARCHAR, a_kleene_star.depth+1,
				a_kleene_star.path|| ARRAY[A.t],
				 CONCAT(a_kleene_star.edges, ARRAY[A.s || '.' || A.t])
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t) IN (SELECT UNNEST(a_kleene_star.edges))
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
