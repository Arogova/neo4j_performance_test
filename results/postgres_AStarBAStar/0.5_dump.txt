seed = 1738055345955815517
2,0.5,18,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.5,13,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.5,13,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.5,13,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.5,13,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.5,14,false,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.5,14,true,10:09:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.5,14,true,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.5,14,true,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.5,14,true,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.5,13,true,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.5,13,true,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.5,13,true,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.5,13,true,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.5,14,false,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.5,14,false,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.5,14,false,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.5,14,false,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.5,14,false,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.5,14,false,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.5,14,false,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.5,14,false,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.5,14,false,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.5,14,false,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.5,14,false,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.5,14,false,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.5,13,true,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.5,13,true,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.5,13,true,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.5,13,true,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.5,31,false,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.5,31,false,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.5,31,false,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.5,32,false,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.5,13,true,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.5,13,true,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.5,13,true,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.5,13,true,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.5,14,true,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.5,14,true,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.5,14,true,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.5,14,true,10:09:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.5,14,false,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.5,14,false,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.5,14,false,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.5,14,false,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.5,14,true,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.5,14,true,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.5,14,true,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.5,14,true,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.5,17,true,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.5,17,true,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.5,17,true,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.5,17,true,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.5,14,false,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.5,14,false,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.5,14,false,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.5,14,false,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.5,20,true,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.5,20,true,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.5,20,true,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.5,20,true,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.5,15,false,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.5,14,false,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.5,14,false,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.5,14,false,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.5,14,false,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.5,14,false,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.5,14,false,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.5,14,false,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.5,33,true,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.5,33,true,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.5,33,true,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.5,33,true,10:09:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.5,16,true,10:09:09
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.5,16,true,10:09:09
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.5,16,true,10:09:09
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.5,16,true,10:09:09
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.5,15,true,10:09:09
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.5,15,true,10:09:09
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.5,15,true,10:09:09
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.5,15,true,10:09:09
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.5,14,true,10:09:09
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.5,14,true,10:09:09
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.5,15,true,10:09:09
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.5,15,true,10:09:09
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.5,23,true,10:09:09
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.5,23,true,10:09:09
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.5,23,true,10:09:09
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.5,23,true,10:09:09
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.5,57,true,10:09:09
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.5,56,true,10:09:09
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.5,56,true,10:09:09
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.5,56,true,10:09:09
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.5,timeout,false,10:19:09
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.5,timeout,false,10:24:09
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.5,timeout,false,10:29:09
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.5,timeout,false,10:34:10
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.5,93896,false,10:37:18
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.5,94066,false,10:38:52
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.5,93975,false,10:40:26
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.5,93893,false,10:42:00
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.5,171,true,10:42:00
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.5,172,true,10:42:00
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.5,172,true,10:42:01
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.5,172,true,10:42:01
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.5,16,true,10:42:01
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.5,16,true,10:42:01
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.5,16,true,10:42:01
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.5,16,true,10:42:01
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.5,29,true,10:42:01
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.5,29,true,10:42:01
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.5,29,true,10:42:01
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.5,29,true,10:42:01
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.5,timeout,false,10:52:02
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.5,timeout,false,10:57:03
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.5,timeout,false,11:02:03
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.5,timeout,false,11:07:04
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.5,9794,false,11:07:23
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.5,10125,false,11:07:33
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.5,10125,false,11:07:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.5,10158,false,11:07:53
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.5,16,true,11:07:53
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.5,16,true,11:07:53
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.5,16,true,11:07:54
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.5,16,true,11:07:54
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.5,26726,false,11:08:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.5,26732,false,11:09:14
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.5,26357,false,11:09:40
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.5,26406,false,11:10:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.5,6423,true,11:10:19
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.5,6415,true,11:10:26
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.5,6164,true,11:10:32
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.5,6035,true,11:10:38
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.5,3294,true,11:10:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.5,3516,true,11:10:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.5,3324,true,11:10:52
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.5,3272,true,11:10:55
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.5,timeout,false,11:20:55
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.5,timeout,false,11:25:55
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.5,timeout,false,11:30:56
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.5,timeout,false,11:35:56
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.5,684,true,11:35:57
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.5,688,true,11:35:58
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.5,683,true,11:35:59
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.5,686,true,11:35:59
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.5,163,true,11:36:00
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.5,163,true,11:36:00
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.5,163,true,11:36:00
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.5,163,true,11:36:00
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.5,timeout,false,11:46:03
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO StartLabel VALUES (9)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.5,timeout,false,11:51:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO StartLabel VALUES (9)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.5,timeout,false,11:56:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO StartLabel VALUES (9)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.5,timeout,false,12:01:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO StartLabel VALUES (9)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.5,14,true,12:01:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.5,13,true,12:01:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.5,13,true,12:01:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.5,13,true,12:01:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.5,timeout,false,12:11:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 5);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.5,timeout,false,12:16:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 5);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.5,timeout,false,12:21:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 5);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.5,timeout,false,12:26:08
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 5);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
