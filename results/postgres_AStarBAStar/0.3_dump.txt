seed = 1737408346576948891
2,0.3,18,false,22:25:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.3,13,false,22:25:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.3,13,false,22:25:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.3,13,false,22:25:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.3,13,false,22:25:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.3,13,false,22:25:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.3,13,false,22:25:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.3,13,false,22:25:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.3,14,false,22:25:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.3,14,false,22:25:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.3,14,false,22:25:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.3,14,false,22:25:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.3,14,false,22:25:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.3,14,false,22:25:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.3,13,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.3,13,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.3,13,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.3,13,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.3,13,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.3,13,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.3,13,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.3,13,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.3,14,false,22:25:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.3,14,true,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.3,14,true,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.3,14,true,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.3,14,true,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.3,14,false,22:25:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.3,14,false,22:25:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.3,14,false,22:25:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.3,14,false,22:25:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.3,14,false,22:25:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.3,14,false,22:25:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.3,14,false,22:25:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.3,14,false,22:25:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.3,14,false,22:25:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.3,14,false,22:25:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.3,14,false,22:25:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.3,14,false,22:25:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.3,14,false,22:25:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.3,14,false,22:25:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.3,14,false,22:25:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.3,14,false,22:25:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.3,14,false,22:25:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.3,14,false,22:25:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.3,14,false,22:25:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.3,14,false,22:25:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.3,14,false,22:25:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.3,14,false,22:25:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.3,14,false,22:25:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.3,14,false,22:25:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.3,14,false,22:25:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.3,14,false,22:25:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.3,14,false,22:25:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.3,14,false,22:25:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.3,14,false,22:25:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.3,87,false,22:25:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.3,87,false,22:25:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.3,87,false,22:25:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.3,87,false,22:25:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.3,14,false,22:25:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.3,14,false,22:25:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.3,14,false,22:25:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.3,14,false,22:25:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.3,14,true,22:25:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.3,14,true,22:25:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.3,14,true,22:25:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.3,14,true,22:25:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.3,17,false,22:25:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.3,17,false,22:25:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.3,17,false,22:25:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.3,17,false,22:25:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.3,14,false,22:25:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.3,14,false,22:25:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.3,14,false,22:25:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.3,14,false,22:25:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.3,16,false,22:25:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.3,16,false,22:25:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.3,16,false,22:25:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.3,15,false,22:25:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.3,14,false,22:25:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.3,14,false,22:25:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.3,14,false,22:25:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.3,14,false,22:25:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.3,14,false,22:25:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.3,14,false,22:25:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.3,14,false,22:25:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.3,14,false,22:25:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.3,15,false,22:25:51
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.3,15,false,22:25:51
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.3,15,false,22:25:51
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.3,15,false,22:25:51
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.3,15,true,22:25:51
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.3,15,true,22:25:51
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.3,15,true,22:25:51
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.3,15,true,22:25:51
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.3,17,false,22:25:51
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.3,17,false,22:25:51
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.3,17,false,22:25:51
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.3,17,false,22:25:51
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.3,13,true,22:25:51
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.3,13,true,22:25:51
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.3,13,true,22:25:51
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.3,13,true,22:25:51
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.3,14,false,22:25:51
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.3,14,false,22:25:51
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.3,14,false,22:25:51
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.3,14,false,22:25:51
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.3,15,false,22:25:51
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.3,15,false,22:25:51
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.3,15,false,22:25:51
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.3,15,false,22:25:51
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.3,223,false,22:25:52
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.3,222,false,22:25:52
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.3,222,false,22:25:52
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.3,222,false,22:25:52
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.3,29,false,22:25:52
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.3,29,false,22:25:52
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.3,29,false,22:25:52
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.3,29,false,22:25:52
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.3,208,false,22:25:53
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 7);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.3,208,false,22:25:53
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 7);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.3,208,false,22:25:53
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 7);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.3,208,false,22:25:54
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 7);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.3,24,true,22:25:54
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.3,24,true,22:25:54
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.3,24,true,22:25:54
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.3,24,true,22:25:54
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.3,14,false,22:25:54
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.3,14,false,22:25:54
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.3,14,false,22:25:54
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.3,14,false,22:25:54
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.3,30,false,22:25:54
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.3,30,false,22:25:54
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.3,30,false,22:25:54
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.3,30,false,22:25:54
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.3,23,true,22:25:54
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.3,23,true,22:25:54
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.3,23,true,22:25:54
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.3,23,true,22:25:54
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.3,131,false,22:25:55
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 11);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 1);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.3,131,false,22:25:55
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 11);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 1);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.3,131,false,22:25:55
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 11);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 1);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.3,131,false,22:25:55
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 11);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 1);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.3,298,true,22:25:56
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 2);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.3,297,true,22:25:56
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 2);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.3,304,true,22:25:56
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 2);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.3,302,true,22:25:56
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 2);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.3,719,false,22:25:58
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.3,716,false,22:25:59
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.3,711,false,22:25:59
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.3,713,false,22:26:00
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.3,53,false,22:26:00
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (8, 11);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO A (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (11, 2);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.3,52,false,22:26:00
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (8, 11);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO A (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (11, 2);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.3,52,false,22:26:00
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (8, 11);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO A (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (11, 2);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.3,52,false,22:26:00
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (8, 11);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO A (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (11, 2);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.3,67,false,22:26:01
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 11);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 11);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO A (s, t) VALUES (9, 12);
INSERT INTO A (s, t) VALUES (10, 1);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO A (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 5);
INSERT INTO B (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.3,67,false,22:26:01
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 11);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 11);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO A (s, t) VALUES (9, 12);
INSERT INTO A (s, t) VALUES (10, 1);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO A (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 5);
INSERT INTO B (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.3,66,false,22:26:01
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 11);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 11);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO A (s, t) VALUES (9, 12);
INSERT INTO A (s, t) VALUES (10, 1);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO A (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 5);
INSERT INTO B (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.3,66,false,22:26:01
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 11);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 11);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO A (s, t) VALUES (9, 12);
INSERT INTO A (s, t) VALUES (10, 1);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO A (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 5);
INSERT INTO B (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.3,166210,false,22:31:34
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (8, 12);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (12)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.3,166089,false,22:34:20
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (8, 12);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (12)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.3,166139,false,22:37:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (8, 12);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (12)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.3,168960,false,22:39:55
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (8, 12);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (12)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.3,timeout,false,22:49:55
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 1);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 12);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO A (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO A (s, t) VALUES (12, 9);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.3,timeout,false,22:54:55
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 1);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 12);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO A (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO A (s, t) VALUES (12, 9);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.3,timeout,false,22:59:55
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 1);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 12);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO A (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO A (s, t) VALUES (12, 9);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.3,timeout,false,23:04:55
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 1);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 12);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO A (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO A (s, t) VALUES (12, 9);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.3,timeout,false,23:14:55
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 11);
INSERT INTO A (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 12);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (7, 12);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 11);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 1);
INSERT INTO B (s, t) VALUES (11, 2);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO A (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO A (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.3,timeout,false,23:19:55
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 11);
INSERT INTO A (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 12);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (7, 12);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 11);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 1);
INSERT INTO B (s, t) VALUES (11, 2);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO A (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO A (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.3,timeout,false,23:24:55
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 11);
INSERT INTO A (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 12);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (7, 12);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 11);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 1);
INSERT INTO B (s, t) VALUES (11, 2);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO A (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO A (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.3,timeout,false,23:29:55
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 11);
INSERT INTO A (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 12);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (7, 12);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 11);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 1);
INSERT INTO B (s, t) VALUES (11, 2);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO A (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO A (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.3,179,false,23:29:55
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 12);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 11);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO A (s, t) VALUES (11, 1);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 6);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.3,178,false,23:29:56
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 12);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 11);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO A (s, t) VALUES (11, 1);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 6);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.3,178,false,23:29:56
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 12);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 11);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO A (s, t) VALUES (11, 1);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 6);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.3,177,false,23:29:56
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 12);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 11);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO A (s, t) VALUES (11, 1);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 6);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.3,timeout,false,23:39:56
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (1, 11);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 13);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (8, 12);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO A (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO A (s, t) VALUES (12, 5);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO A (s, t) VALUES (12, 11);
INSERT INTO B (s, t) VALUES (12, 12);
INSERT INTO A (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 3);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO A (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (13, 11);
INSERT INTO A (s, t) VALUES (13, 13);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.3,timeout,false,23:44:56
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (1, 11);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 13);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (8, 12);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO A (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO A (s, t) VALUES (12, 5);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO A (s, t) VALUES (12, 11);
INSERT INTO B (s, t) VALUES (12, 12);
INSERT INTO A (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 3);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO A (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (13, 11);
INSERT INTO A (s, t) VALUES (13, 13);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.3,timeout,false,23:49:56
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (1, 11);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 13);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (8, 12);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO A (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO A (s, t) VALUES (12, 5);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO A (s, t) VALUES (12, 11);
INSERT INTO B (s, t) VALUES (12, 12);
INSERT INTO A (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 3);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO A (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (13, 11);
INSERT INTO A (s, t) VALUES (13, 13);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.3,timeout,false,23:54:56
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (1, 11);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 13);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (8, 12);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO A (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO A (s, t) VALUES (12, 5);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO A (s, t) VALUES (12, 11);
INSERT INTO B (s, t) VALUES (12, 12);
INSERT INTO A (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 3);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO A (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (13, 11);
INSERT INTO A (s, t) VALUES (13, 13);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.3,timeout,false,00:04:56
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 11);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 12);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 7);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 13);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO A (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO A (s, t) VALUES (12, 13);
INSERT INTO B (s, t) VALUES (13, 1);
INSERT INTO A (s, t) VALUES (13, 3);
INSERT INTO A (s, t) VALUES (13, 5);
INSERT INTO B (s, t) VALUES (13, 7);
INSERT INTO A (s, t) VALUES (13, 10);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.3,timeout,false,00:09:56
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 11);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 12);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 7);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 13);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO A (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO A (s, t) VALUES (12, 13);
INSERT INTO B (s, t) VALUES (13, 1);
INSERT INTO A (s, t) VALUES (13, 3);
INSERT INTO A (s, t) VALUES (13, 5);
INSERT INTO B (s, t) VALUES (13, 7);
INSERT INTO A (s, t) VALUES (13, 10);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.3,timeout,false,00:14:56
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 11);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 12);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 7);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 13);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO A (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO A (s, t) VALUES (12, 13);
INSERT INTO B (s, t) VALUES (13, 1);
INSERT INTO A (s, t) VALUES (13, 3);
INSERT INTO A (s, t) VALUES (13, 5);
INSERT INTO B (s, t) VALUES (13, 7);
INSERT INTO A (s, t) VALUES (13, 10);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.3,timeout,false,00:19:56
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 11);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 12);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 7);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 13);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO A (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO A (s, t) VALUES (12, 13);
INSERT INTO B (s, t) VALUES (13, 1);
INSERT INTO A (s, t) VALUES (13, 3);
INSERT INTO A (s, t) VALUES (13, 5);
INSERT INTO B (s, t) VALUES (13, 7);
INSERT INTO A (s, t) VALUES (13, 10);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.3,1453,false,00:19:59
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (6, 13);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 13);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 13);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 12);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (10, 10);
INSERT INTO A (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 8);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO A (s, t) VALUES (13, 3);
INSERT INTO B (s, t) VALUES (13, 4);
INSERT INTO A (s, t) VALUES (13, 5);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (13, 9);
INSERT INTO B (s, t) VALUES (13, 11);
INSERT INTO StartLabel VALUES (12)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.3,1463,false,00:20:01
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (6, 13);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 13);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 13);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 12);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (10, 10);
INSERT INTO A (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 8);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO A (s, t) VALUES (13, 3);
INSERT INTO B (s, t) VALUES (13, 4);
INSERT INTO A (s, t) VALUES (13, 5);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (13, 9);
INSERT INTO B (s, t) VALUES (13, 11);
INSERT INTO StartLabel VALUES (12)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.3,1442,false,00:20:02
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (6, 13);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 13);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 13);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 12);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (10, 10);
INSERT INTO A (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 8);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO A (s, t) VALUES (13, 3);
INSERT INTO B (s, t) VALUES (13, 4);
INSERT INTO A (s, t) VALUES (13, 5);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (13, 9);
INSERT INTO B (s, t) VALUES (13, 11);
INSERT INTO StartLabel VALUES (12)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.3,1475,false,00:20:04
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (6, 13);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 13);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 13);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 12);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (10, 10);
INSERT INTO A (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 8);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO A (s, t) VALUES (13, 3);
INSERT INTO B (s, t) VALUES (13, 4);
INSERT INTO A (s, t) VALUES (13, 5);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (13, 9);
INSERT INTO B (s, t) VALUES (13, 11);
INSERT INTO StartLabel VALUES (12)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.3,122,false,00:20:04
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 11);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (1, 13);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (6, 12);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 11);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 10);
INSERT INTO A (s, t) VALUES (11, 2);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (11, 13);
INSERT INTO A (s, t) VALUES (12, 0);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 2);
INSERT INTO A (s, t) VALUES (13, 3);
INSERT INTO B (s, t) VALUES (13, 7);
INSERT INTO B (s, t) VALUES (13, 11);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.3,117,false,00:20:04
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 11);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (1, 13);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (6, 12);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 11);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 10);
INSERT INTO A (s, t) VALUES (11, 2);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (11, 13);
INSERT INTO A (s, t) VALUES (12, 0);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 2);
INSERT INTO A (s, t) VALUES (13, 3);
INSERT INTO B (s, t) VALUES (13, 7);
INSERT INTO B (s, t) VALUES (13, 11);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.3,116,false,00:20:04
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 11);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (1, 13);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (6, 12);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 11);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 10);
INSERT INTO A (s, t) VALUES (11, 2);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (11, 13);
INSERT INTO A (s, t) VALUES (12, 0);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 2);
INSERT INTO A (s, t) VALUES (13, 3);
INSERT INTO B (s, t) VALUES (13, 7);
INSERT INTO B (s, t) VALUES (13, 11);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.3,117,false,00:20:04
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 11);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (1, 13);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (6, 12);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 11);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 10);
INSERT INTO A (s, t) VALUES (11, 2);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (11, 13);
INSERT INTO A (s, t) VALUES (12, 0);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 2);
INSERT INTO A (s, t) VALUES (13, 3);
INSERT INTO B (s, t) VALUES (13, 7);
INSERT INTO B (s, t) VALUES (13, 11);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.3,170982,false,00:25:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (0, 11);
INSERT INTO A (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 12);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 12);
INSERT INTO A (s, t) VALUES (12, 0);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 11);
INSERT INTO A (s, t) VALUES (12, 13);
INSERT INTO B (s, t) VALUES (13, 1);
INSERT INTO B (s, t) VALUES (13, 3);
INSERT INTO A (s, t) VALUES (13, 5);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.3,170725,false,00:28:37
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (0, 11);
INSERT INTO A (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 12);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 12);
INSERT INTO A (s, t) VALUES (12, 0);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 11);
INSERT INTO A (s, t) VALUES (12, 13);
INSERT INTO B (s, t) VALUES (13, 1);
INSERT INTO B (s, t) VALUES (13, 3);
INSERT INTO A (s, t) VALUES (13, 5);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.3,168724,false,00:31:26
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (0, 11);
INSERT INTO A (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 12);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 12);
INSERT INTO A (s, t) VALUES (12, 0);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 11);
INSERT INTO A (s, t) VALUES (12, 13);
INSERT INTO B (s, t) VALUES (13, 1);
INSERT INTO B (s, t) VALUES (13, 3);
INSERT INTO A (s, t) VALUES (13, 5);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.3,170009,false,00:34:16
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (0, 11);
INSERT INTO A (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 12);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 12);
INSERT INTO A (s, t) VALUES (12, 0);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 11);
INSERT INTO A (s, t) VALUES (12, 13);
INSERT INTO B (s, t) VALUES (13, 1);
INSERT INTO B (s, t) VALUES (13, 3);
INSERT INTO A (s, t) VALUES (13, 5);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.3,16,true,00:34:16
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 14);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (1, 14);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (2, 11);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 13);
INSERT INTO A (s, t) VALUES (3, 14);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 14);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 13);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 14);
INSERT INTO A (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO B (s, t) VALUES (11, 10);
INSERT INTO A (s, t) VALUES (12, 3);
INSERT INTO A (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO A (s, t) VALUES (12, 9);
INSERT INTO B (s, t) VALUES (12, 11);
INSERT INTO A (s, t) VALUES (12, 14);
INSERT INTO A (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (13, 10);
INSERT INTO A (s, t) VALUES (13, 11);
INSERT INTO A (s, t) VALUES (14, 0);
INSERT INTO A (s, t) VALUES (14, 8);
INSERT INTO B (s, t) VALUES (14, 12);
INSERT INTO B (s, t) VALUES (14, 13);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.3,16,true,00:34:16
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 14);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (1, 14);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (2, 11);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 13);
INSERT INTO A (s, t) VALUES (3, 14);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 14);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 13);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 14);
INSERT INTO A (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO B (s, t) VALUES (11, 10);
INSERT INTO A (s, t) VALUES (12, 3);
INSERT INTO A (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO A (s, t) VALUES (12, 9);
INSERT INTO B (s, t) VALUES (12, 11);
INSERT INTO A (s, t) VALUES (12, 14);
INSERT INTO A (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (13, 10);
INSERT INTO A (s, t) VALUES (13, 11);
INSERT INTO A (s, t) VALUES (14, 0);
INSERT INTO A (s, t) VALUES (14, 8);
INSERT INTO B (s, t) VALUES (14, 12);
INSERT INTO B (s, t) VALUES (14, 13);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.3,16,true,00:34:16
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 14);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (1, 14);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (2, 11);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 13);
INSERT INTO A (s, t) VALUES (3, 14);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 14);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 13);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 14);
INSERT INTO A (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO B (s, t) VALUES (11, 10);
INSERT INTO A (s, t) VALUES (12, 3);
INSERT INTO A (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO A (s, t) VALUES (12, 9);
INSERT INTO B (s, t) VALUES (12, 11);
INSERT INTO A (s, t) VALUES (12, 14);
INSERT INTO A (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (13, 10);
INSERT INTO A (s, t) VALUES (13, 11);
INSERT INTO A (s, t) VALUES (14, 0);
INSERT INTO A (s, t) VALUES (14, 8);
INSERT INTO B (s, t) VALUES (14, 12);
INSERT INTO B (s, t) VALUES (14, 13);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.3,16,true,00:34:16
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 14);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (1, 14);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (2, 11);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 13);
INSERT INTO A (s, t) VALUES (3, 14);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 14);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 13);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 14);
INSERT INTO A (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO B (s, t) VALUES (11, 10);
INSERT INTO A (s, t) VALUES (12, 3);
INSERT INTO A (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO A (s, t) VALUES (12, 9);
INSERT INTO B (s, t) VALUES (12, 11);
INSERT INTO A (s, t) VALUES (12, 14);
INSERT INTO A (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (13, 10);
INSERT INTO A (s, t) VALUES (13, 11);
INSERT INTO A (s, t) VALUES (14, 0);
INSERT INTO A (s, t) VALUES (14, 8);
INSERT INTO B (s, t) VALUES (14, 12);
INSERT INTO B (s, t) VALUES (14, 13);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.3,27,true,00:34:16
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 13);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (7, 13);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO A (s, t) VALUES (9, 12);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO B (s, t) VALUES (10, 13);
INSERT INTO B (s, t) VALUES (10, 14);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 12);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 10);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 3);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO A (s, t) VALUES (13, 6);
INSERT INTO A (s, t) VALUES (14, 1);
INSERT INTO A (s, t) VALUES (14, 4);
INSERT INTO A (s, t) VALUES (14, 6);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.3,27,true,00:34:16
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 13);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (7, 13);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO A (s, t) VALUES (9, 12);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO B (s, t) VALUES (10, 13);
INSERT INTO B (s, t) VALUES (10, 14);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 12);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 10);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 3);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO A (s, t) VALUES (13, 6);
INSERT INTO A (s, t) VALUES (14, 1);
INSERT INTO A (s, t) VALUES (14, 4);
INSERT INTO A (s, t) VALUES (14, 6);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.3,27,true,00:34:16
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 13);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (7, 13);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO A (s, t) VALUES (9, 12);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO B (s, t) VALUES (10, 13);
INSERT INTO B (s, t) VALUES (10, 14);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 12);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 10);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 3);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO A (s, t) VALUES (13, 6);
INSERT INTO A (s, t) VALUES (14, 1);
INSERT INTO A (s, t) VALUES (14, 4);
INSERT INTO A (s, t) VALUES (14, 6);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.3,27,true,00:34:16
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 13);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (7, 13);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO A (s, t) VALUES (9, 12);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO B (s, t) VALUES (10, 13);
INSERT INTO B (s, t) VALUES (10, 14);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 12);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 10);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 3);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO A (s, t) VALUES (13, 6);
INSERT INTO A (s, t) VALUES (14, 1);
INSERT INTO A (s, t) VALUES (14, 4);
INSERT INTO A (s, t) VALUES (14, 6);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.3,73,true,00:34:16
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (0, 14);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 12);
INSERT INTO A (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 11);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (5, 11);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 13);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 13);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 2);
INSERT INTO A (s, t) VALUES (11, 5);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 5);
INSERT INTO B (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO A (s, t) VALUES (13, 2);
INSERT INTO B (s, t) VALUES (13, 13);
INSERT INTO B (s, t) VALUES (14, 0);
INSERT INTO B (s, t) VALUES (14, 1);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 8);
INSERT INTO B (s, t) VALUES (14, 9);
INSERT INTO B (s, t) VALUES (14, 10);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.3,72,true,00:34:16
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (0, 14);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 12);
INSERT INTO A (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 11);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (5, 11);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 13);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 13);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 2);
INSERT INTO A (s, t) VALUES (11, 5);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 5);
INSERT INTO B (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO A (s, t) VALUES (13, 2);
INSERT INTO B (s, t) VALUES (13, 13);
INSERT INTO B (s, t) VALUES (14, 0);
INSERT INTO B (s, t) VALUES (14, 1);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 8);
INSERT INTO B (s, t) VALUES (14, 9);
INSERT INTO B (s, t) VALUES (14, 10);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.3,72,true,00:34:16
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (0, 14);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 12);
INSERT INTO A (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 11);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (5, 11);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 13);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 13);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 2);
INSERT INTO A (s, t) VALUES (11, 5);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 5);
INSERT INTO B (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO A (s, t) VALUES (13, 2);
INSERT INTO B (s, t) VALUES (13, 13);
INSERT INTO B (s, t) VALUES (14, 0);
INSERT INTO B (s, t) VALUES (14, 1);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 8);
INSERT INTO B (s, t) VALUES (14, 9);
INSERT INTO B (s, t) VALUES (14, 10);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.3,72,true,00:34:16
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (0, 14);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 12);
INSERT INTO A (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 11);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (5, 11);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 13);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 13);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 2);
INSERT INTO A (s, t) VALUES (11, 5);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 5);
INSERT INTO B (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO A (s, t) VALUES (13, 2);
INSERT INTO B (s, t) VALUES (13, 13);
INSERT INTO B (s, t) VALUES (14, 0);
INSERT INTO B (s, t) VALUES (14, 1);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 8);
INSERT INTO B (s, t) VALUES (14, 9);
INSERT INTO B (s, t) VALUES (14, 10);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.3,31741,true,00:35:20
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 14);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO B (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (6, 13);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 12);
INSERT INTO B (s, t) VALUES (8, 14);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (9, 14);
INSERT INTO B (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (10, 14);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (11, 11);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO A (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 5);
INSERT INTO B (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO B (s, t) VALUES (12, 14);
INSERT INTO B (s, t) VALUES (13, 1);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO B (s, t) VALUES (13, 7);
INSERT INTO A (s, t) VALUES (13, 8);
INSERT INTO B (s, t) VALUES (13, 11);
INSERT INTO B (s, t) VALUES (13, 12);
INSERT INTO A (s, t) VALUES (13, 13);
INSERT INTO B (s, t) VALUES (14, 5);
INSERT INTO B (s, t) VALUES (14, 9);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (11)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.3,31773,true,00:35:52
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 14);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO B (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (6, 13);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 12);
INSERT INTO B (s, t) VALUES (8, 14);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (9, 14);
INSERT INTO B (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (10, 14);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (11, 11);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO A (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 5);
INSERT INTO B (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO B (s, t) VALUES (12, 14);
INSERT INTO B (s, t) VALUES (13, 1);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO B (s, t) VALUES (13, 7);
INSERT INTO A (s, t) VALUES (13, 8);
INSERT INTO B (s, t) VALUES (13, 11);
INSERT INTO B (s, t) VALUES (13, 12);
INSERT INTO A (s, t) VALUES (13, 13);
INSERT INTO B (s, t) VALUES (14, 5);
INSERT INTO B (s, t) VALUES (14, 9);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (11)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.3,31650,true,00:36:23
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 14);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO B (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (6, 13);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 12);
INSERT INTO B (s, t) VALUES (8, 14);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (9, 14);
INSERT INTO B (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (10, 14);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (11, 11);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO A (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 5);
INSERT INTO B (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO B (s, t) VALUES (12, 14);
INSERT INTO B (s, t) VALUES (13, 1);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO B (s, t) VALUES (13, 7);
INSERT INTO A (s, t) VALUES (13, 8);
INSERT INTO B (s, t) VALUES (13, 11);
INSERT INTO B (s, t) VALUES (13, 12);
INSERT INTO A (s, t) VALUES (13, 13);
INSERT INTO B (s, t) VALUES (14, 5);
INSERT INTO B (s, t) VALUES (14, 9);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (11)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.3,31830,true,00:36:55
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 14);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO B (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (6, 13);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 12);
INSERT INTO B (s, t) VALUES (8, 14);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (9, 14);
INSERT INTO B (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (10, 14);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (11, 11);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO A (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 5);
INSERT INTO B (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO B (s, t) VALUES (12, 14);
INSERT INTO B (s, t) VALUES (13, 1);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO B (s, t) VALUES (13, 7);
INSERT INTO A (s, t) VALUES (13, 8);
INSERT INTO B (s, t) VALUES (13, 11);
INSERT INTO B (s, t) VALUES (13, 12);
INSERT INTO A (s, t) VALUES (13, 13);
INSERT INTO B (s, t) VALUES (14, 5);
INSERT INTO B (s, t) VALUES (14, 9);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (11)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.3,1891,false,00:36:59
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 12);
INSERT INTO B (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (6, 14);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 12);
INSERT INTO B (s, t) VALUES (7, 14);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 13);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 14);
INSERT INTO A (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (11, 14);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO A (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO A (s, t) VALUES (13, 6);
INSERT INTO A (s, t) VALUES (14, 0);
INSERT INTO B (s, t) VALUES (14, 13);
INSERT INTO StartLabel VALUES (9)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.3,1887,false,00:37:01
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 12);
INSERT INTO B (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (6, 14);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 12);
INSERT INTO B (s, t) VALUES (7, 14);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 13);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 14);
INSERT INTO A (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (11, 14);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO A (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO A (s, t) VALUES (13, 6);
INSERT INTO A (s, t) VALUES (14, 0);
INSERT INTO B (s, t) VALUES (14, 13);
INSERT INTO StartLabel VALUES (9)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.3,1884,false,00:37:03
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 12);
INSERT INTO B (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (6, 14);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 12);
INSERT INTO B (s, t) VALUES (7, 14);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 13);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 14);
INSERT INTO A (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (11, 14);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO A (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO A (s, t) VALUES (13, 6);
INSERT INTO A (s, t) VALUES (14, 0);
INSERT INTO B (s, t) VALUES (14, 13);
INSERT INTO StartLabel VALUES (9)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.3,1888,false,00:37:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 12);
INSERT INTO B (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (6, 14);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 12);
INSERT INTO B (s, t) VALUES (7, 14);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 13);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 14);
INSERT INTO A (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (11, 14);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO A (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO A (s, t) VALUES (13, 6);
INSERT INTO A (s, t) VALUES (14, 0);
INSERT INTO B (s, t) VALUES (14, 13);
INSERT INTO StartLabel VALUES (9)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
16,0.3,159,true,00:37:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO A (s, t) VALUES (0, 15);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 12);
INSERT INTO B (s, t) VALUES (1, 14);
INSERT INTO B (s, t) VALUES (1, 15);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (2, 15);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO B (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 14);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 12);
INSERT INTO A (s, t) VALUES (7, 14);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 15);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (10, 13);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 1);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (11, 12);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 7);
INSERT INTO A (s, t) VALUES (12, 11);
INSERT INTO A (s, t) VALUES (12, 14);
INSERT INTO A (s, t) VALUES (13, 7);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO B (s, t) VALUES (13, 10);
INSERT INTO B (s, t) VALUES (13, 13);
INSERT INTO B (s, t) VALUES (14, 0);
INSERT INTO A (s, t) VALUES (14, 2);
INSERT INTO B (s, t) VALUES (14, 3);
INSERT INTO A (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 15);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO B (s, t) VALUES (15, 2);
INSERT INTO A (s, t) VALUES (15, 4);
INSERT INTO A (s, t) VALUES (15, 8);
INSERT INTO A (s, t) VALUES (15, 12);
INSERT INTO B (s, t) VALUES (15, 14);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
16,0.3,165,true,00:37:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO A (s, t) VALUES (0, 15);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 12);
INSERT INTO B (s, t) VALUES (1, 14);
INSERT INTO B (s, t) VALUES (1, 15);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (2, 15);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO B (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 14);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 12);
INSERT INTO A (s, t) VALUES (7, 14);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 15);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (10, 13);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 1);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (11, 12);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 7);
INSERT INTO A (s, t) VALUES (12, 11);
INSERT INTO A (s, t) VALUES (12, 14);
INSERT INTO A (s, t) VALUES (13, 7);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO B (s, t) VALUES (13, 10);
INSERT INTO B (s, t) VALUES (13, 13);
INSERT INTO B (s, t) VALUES (14, 0);
INSERT INTO A (s, t) VALUES (14, 2);
INSERT INTO B (s, t) VALUES (14, 3);
INSERT INTO A (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 15);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO B (s, t) VALUES (15, 2);
INSERT INTO A (s, t) VALUES (15, 4);
INSERT INTO A (s, t) VALUES (15, 8);
INSERT INTO A (s, t) VALUES (15, 12);
INSERT INTO B (s, t) VALUES (15, 14);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
16,0.3,161,true,00:37:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO A (s, t) VALUES (0, 15);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 12);
INSERT INTO B (s, t) VALUES (1, 14);
INSERT INTO B (s, t) VALUES (1, 15);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (2, 15);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO B (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 14);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 12);
INSERT INTO A (s, t) VALUES (7, 14);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 15);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (10, 13);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 1);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (11, 12);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 7);
INSERT INTO A (s, t) VALUES (12, 11);
INSERT INTO A (s, t) VALUES (12, 14);
INSERT INTO A (s, t) VALUES (13, 7);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO B (s, t) VALUES (13, 10);
INSERT INTO B (s, t) VALUES (13, 13);
INSERT INTO B (s, t) VALUES (14, 0);
INSERT INTO A (s, t) VALUES (14, 2);
INSERT INTO B (s, t) VALUES (14, 3);
INSERT INTO A (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 15);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO B (s, t) VALUES (15, 2);
INSERT INTO A (s, t) VALUES (15, 4);
INSERT INTO A (s, t) VALUES (15, 8);
INSERT INTO A (s, t) VALUES (15, 12);
INSERT INTO B (s, t) VALUES (15, 14);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
16,0.3,161,true,00:37:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO A (s, t) VALUES (0, 15);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 12);
INSERT INTO B (s, t) VALUES (1, 14);
INSERT INTO B (s, t) VALUES (1, 15);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (2, 15);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO B (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 14);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 12);
INSERT INTO A (s, t) VALUES (7, 14);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 15);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (10, 13);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 1);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (11, 12);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 7);
INSERT INTO A (s, t) VALUES (12, 11);
INSERT INTO A (s, t) VALUES (12, 14);
INSERT INTO A (s, t) VALUES (13, 7);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO B (s, t) VALUES (13, 10);
INSERT INTO B (s, t) VALUES (13, 13);
INSERT INTO B (s, t) VALUES (14, 0);
INSERT INTO A (s, t) VALUES (14, 2);
INSERT INTO B (s, t) VALUES (14, 3);
INSERT INTO A (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 15);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO B (s, t) VALUES (15, 2);
INSERT INTO A (s, t) VALUES (15, 4);
INSERT INTO A (s, t) VALUES (15, 8);
INSERT INTO A (s, t) VALUES (15, 12);
INSERT INTO B (s, t) VALUES (15, 14);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
16,0.3,timeout,false,00:47:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (0, 14);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (2, 14);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 11);
INSERT INTO B (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO B (s, t) VALUES (3, 14);
INSERT INTO A (s, t) VALUES (3, 15);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 15);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (6, 12);
INSERT INTO A (s, t) VALUES (6, 14);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 13);
INSERT INTO A (s, t) VALUES (7, 14);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (8, 11);
INSERT INTO B (s, t) VALUES (8, 15);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 14);
INSERT INTO A (s, t) VALUES (9, 15);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (10, 13);
INSERT INTO B (s, t) VALUES (10, 15);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 14);
INSERT INTO B (s, t) VALUES (11, 15);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO A (s, t) VALUES (12, 4);
INSERT INTO A (s, t) VALUES (12, 7);
INSERT INTO A (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 11);
INSERT INTO B (s, t) VALUES (12, 12);
INSERT INTO A (s, t) VALUES (13, 6);
INSERT INTO A (s, t) VALUES (13, 10);
INSERT INTO A (s, t) VALUES (13, 11);
INSERT INTO B (s, t) VALUES (13, 13);
INSERT INTO B (s, t) VALUES (13, 14);
INSERT INTO A (s, t) VALUES (13, 15);
INSERT INTO A (s, t) VALUES (14, 1);
INSERT INTO B (s, t) VALUES (14, 5);
INSERT INTO B (s, t) VALUES (14, 9);
INSERT INTO A (s, t) VALUES (14, 11);
INSERT INTO B (s, t) VALUES (14, 13);
INSERT INTO A (s, t) VALUES (14, 15);
INSERT INTO B (s, t) VALUES (15, 1);
INSERT INTO B (s, t) VALUES (15, 2);
INSERT INTO A (s, t) VALUES (15, 4);
INSERT INTO A (s, t) VALUES (15, 5);
INSERT INTO B (s, t) VALUES (15, 8);
INSERT INTO A (s, t) VALUES (15, 12);
INSERT INTO B (s, t) VALUES (15, 14);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
16,0.3,timeout,false,00:52:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (0, 14);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (2, 14);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 11);
INSERT INTO B (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO B (s, t) VALUES (3, 14);
INSERT INTO A (s, t) VALUES (3, 15);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 15);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (6, 12);
INSERT INTO A (s, t) VALUES (6, 14);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 13);
INSERT INTO A (s, t) VALUES (7, 14);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (8, 11);
INSERT INTO B (s, t) VALUES (8, 15);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 14);
INSERT INTO A (s, t) VALUES (9, 15);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (10, 13);
INSERT INTO B (s, t) VALUES (10, 15);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 14);
INSERT INTO B (s, t) VALUES (11, 15);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO A (s, t) VALUES (12, 4);
INSERT INTO A (s, t) VALUES (12, 7);
INSERT INTO A (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 11);
INSERT INTO B (s, t) VALUES (12, 12);
INSERT INTO A (s, t) VALUES (13, 6);
INSERT INTO A (s, t) VALUES (13, 10);
INSERT INTO A (s, t) VALUES (13, 11);
INSERT INTO B (s, t) VALUES (13, 13);
INSERT INTO B (s, t) VALUES (13, 14);
INSERT INTO A (s, t) VALUES (13, 15);
INSERT INTO A (s, t) VALUES (14, 1);
INSERT INTO B (s, t) VALUES (14, 5);
INSERT INTO B (s, t) VALUES (14, 9);
INSERT INTO A (s, t) VALUES (14, 11);
INSERT INTO B (s, t) VALUES (14, 13);
INSERT INTO A (s, t) VALUES (14, 15);
INSERT INTO B (s, t) VALUES (15, 1);
INSERT INTO B (s, t) VALUES (15, 2);
INSERT INTO A (s, t) VALUES (15, 4);
INSERT INTO A (s, t) VALUES (15, 5);
INSERT INTO B (s, t) VALUES (15, 8);
INSERT INTO A (s, t) VALUES (15, 12);
INSERT INTO B (s, t) VALUES (15, 14);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
16,0.3,timeout,false,00:57:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (0, 14);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (2, 14);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 11);
INSERT INTO B (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO B (s, t) VALUES (3, 14);
INSERT INTO A (s, t) VALUES (3, 15);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 15);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (6, 12);
INSERT INTO A (s, t) VALUES (6, 14);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 13);
INSERT INTO A (s, t) VALUES (7, 14);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (8, 11);
INSERT INTO B (s, t) VALUES (8, 15);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 14);
INSERT INTO A (s, t) VALUES (9, 15);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (10, 13);
INSERT INTO B (s, t) VALUES (10, 15);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 14);
INSERT INTO B (s, t) VALUES (11, 15);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO A (s, t) VALUES (12, 4);
INSERT INTO A (s, t) VALUES (12, 7);
INSERT INTO A (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 11);
INSERT INTO B (s, t) VALUES (12, 12);
INSERT INTO A (s, t) VALUES (13, 6);
INSERT INTO A (s, t) VALUES (13, 10);
INSERT INTO A (s, t) VALUES (13, 11);
INSERT INTO B (s, t) VALUES (13, 13);
INSERT INTO B (s, t) VALUES (13, 14);
INSERT INTO A (s, t) VALUES (13, 15);
INSERT INTO A (s, t) VALUES (14, 1);
INSERT INTO B (s, t) VALUES (14, 5);
INSERT INTO B (s, t) VALUES (14, 9);
INSERT INTO A (s, t) VALUES (14, 11);
INSERT INTO B (s, t) VALUES (14, 13);
INSERT INTO A (s, t) VALUES (14, 15);
INSERT INTO B (s, t) VALUES (15, 1);
INSERT INTO B (s, t) VALUES (15, 2);
INSERT INTO A (s, t) VALUES (15, 4);
INSERT INTO A (s, t) VALUES (15, 5);
INSERT INTO B (s, t) VALUES (15, 8);
INSERT INTO A (s, t) VALUES (15, 12);
INSERT INTO B (s, t) VALUES (15, 14);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
16,0.3,timeout,false,01:02:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (0, 14);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (2, 14);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 11);
INSERT INTO B (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO B (s, t) VALUES (3, 14);
INSERT INTO A (s, t) VALUES (3, 15);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 15);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (6, 12);
INSERT INTO A (s, t) VALUES (6, 14);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 13);
INSERT INTO A (s, t) VALUES (7, 14);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (8, 11);
INSERT INTO B (s, t) VALUES (8, 15);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 14);
INSERT INTO A (s, t) VALUES (9, 15);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (10, 13);
INSERT INTO B (s, t) VALUES (10, 15);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 14);
INSERT INTO B (s, t) VALUES (11, 15);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO A (s, t) VALUES (12, 4);
INSERT INTO A (s, t) VALUES (12, 7);
INSERT INTO A (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 11);
INSERT INTO B (s, t) VALUES (12, 12);
INSERT INTO A (s, t) VALUES (13, 6);
INSERT INTO A (s, t) VALUES (13, 10);
INSERT INTO A (s, t) VALUES (13, 11);
INSERT INTO B (s, t) VALUES (13, 13);
INSERT INTO B (s, t) VALUES (13, 14);
INSERT INTO A (s, t) VALUES (13, 15);
INSERT INTO A (s, t) VALUES (14, 1);
INSERT INTO B (s, t) VALUES (14, 5);
INSERT INTO B (s, t) VALUES (14, 9);
INSERT INTO A (s, t) VALUES (14, 11);
INSERT INTO B (s, t) VALUES (14, 13);
INSERT INTO A (s, t) VALUES (14, 15);
INSERT INTO B (s, t) VALUES (15, 1);
INSERT INTO B (s, t) VALUES (15, 2);
INSERT INTO A (s, t) VALUES (15, 4);
INSERT INTO A (s, t) VALUES (15, 5);
INSERT INTO B (s, t) VALUES (15, 8);
INSERT INTO A (s, t) VALUES (15, 12);
INSERT INTO B (s, t) VALUES (15, 14);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
