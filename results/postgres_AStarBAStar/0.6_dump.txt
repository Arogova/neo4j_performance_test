seed = 1738069421365483805
2,0.6,19,false,14:03:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.6,15,false,14:03:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.6,14,false,14:03:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.6,15,false,14:03:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.6,15,false,14:03:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.6,15,false,14:03:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.6,15,false,14:03:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.6,15,false,14:03:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.6,14,false,14:03:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.6,13,false,14:03:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.6,13,false,14:03:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.6,15,false,14:03:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.6,15,false,14:03:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.6,14,false,14:03:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.6,15,false,14:03:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.6,15,false,14:03:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.6,14,true,14:03:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.6,13,true,14:03:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.6,13,true,14:03:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.6,13,true,14:03:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.6,14,false,14:03:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.6,15,false,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.6,17,false,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.6,14,false,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.6,13,false,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.6,13,false,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.6,13,false,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.6,13,false,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.6,14,false,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.6,14,false,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.6,14,false,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.6,14,false,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.6,14,false,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.6,15,false,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.6,14,false,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.6,14,false,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.6,14,true,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.6,13,true,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.6,14,true,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.6,14,true,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.6,14,false,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.6,14,false,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.6,14,false,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.6,15,false,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.6,14,true,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.6,14,true,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.6,14,true,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.6,14,true,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.6,14,true,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.6,14,true,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.6,14,true,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.6,14,true,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.6,13,true,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.6,13,true,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.6,13,true,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.6,13,true,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.6,19,true,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.6,14,true,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.6,14,true,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.6,14,true,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.6,14,true,14:03:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.6,14,true,14:03:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.6,14,true,14:03:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.6,14,true,14:03:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.6,19,false,14:03:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.6,19,false,14:03:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.6,19,false,14:03:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.6,19,false,14:03:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.6,73,false,14:03:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.6,74,false,14:03:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.6,75,false,14:03:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.6,74,false,14:03:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.6,14,false,14:03:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.6,14,false,14:03:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.6,14,false,14:03:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.6,14,false,14:03:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.6,14,false,14:03:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.6,14,false,14:03:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.6,14,false,14:03:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.6,14,false,14:03:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.6,15,false,14:03:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.6,14,false,14:03:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.6,14,false,14:03:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.6,14,false,14:03:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.6,16,false,14:03:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.6,16,false,14:03:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.6,16,false,14:03:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.6,16,false,14:03:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.6,350,false,14:03:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.6,351,false,14:03:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.6,352,false,14:03:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.6,353,false,14:03:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.6,55,true,14:03:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.6,55,true,14:03:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.6,55,true,14:03:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.6,55,true,14:03:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.6,15,true,14:03:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.6,15,true,14:03:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.6,15,true,14:03:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.6,15,true,14:03:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.6,59,true,14:03:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.6,59,true,14:03:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.6,59,true,14:03:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.6,59,true,14:03:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.6,timeout,false,14:13:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.6,timeout,false,14:18:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.6,timeout,false,14:23:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.6,timeout,false,14:28:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.6,66,true,14:28:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.6,66,true,14:28:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.6,65,true,14:28:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.6,66,true,14:28:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.6,19,true,14:28:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.6,21,true,14:28:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.6,19,true,14:28:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.6,19,true,14:28:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.6,233,true,14:28:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.6,231,true,14:28:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.6,231,true,14:28:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.6,233,true,14:28:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.6,15,false,14:28:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.6,15,false,14:28:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.6,15,false,14:28:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.6,15,false,14:28:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.6,3139,true,14:28:54
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.6,3123,true,14:28:57
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.6,3136,true,14:29:01
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.6,3125,true,14:29:04
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.6,21,true,14:29:04
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.6,21,true,14:29:04
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.6,21,true,14:29:04
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.6,21,true,14:29:04
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.6,timeout,false,14:39:04
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.6,timeout,false,14:44:04
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.6,timeout,false,14:49:04
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.6,timeout,false,14:54:04
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.6,309,true,14:54:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.6,311,true,14:54:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.6,309,true,14:54:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.6,309,true,14:54:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.6,178215,false,15:00:01
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.6,177924,false,15:02:59
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.6,176028,false,15:05:55
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.6,174673,false,15:08:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.6,13,true,15:08:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.6,13,true,15:08:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.6,13,true,15:08:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.6,13,true,15:08:50
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.6,2044,true,15:08:54
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.6,2053,true,15:08:56
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.6,2043,true,15:08:58
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.6,2043,true,15:09:00
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.6,118067,true,15:12:56
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.6,119419,true,15:14:55
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.6,118511,true,15:16:54
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.6,117950,true,15:18:52
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.6,13521,true,15:19:19
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.6,13724,true,15:19:33
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.6,13691,true,15:19:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.6,13688,true,15:20:00
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
