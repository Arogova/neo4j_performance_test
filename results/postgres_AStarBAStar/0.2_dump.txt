seed = 1737975282413466248
2,0.2,18,false,11:54:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.2,13,false,11:54:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.2,13,false,11:54:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.2,13,false,11:54:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.2,14,false,11:54:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.2,14,false,11:54:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.2,14,false,11:54:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.2,14,false,11:54:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.2,14,false,11:54:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.2,13,false,11:54:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.2,13,false,11:54:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.2,13,false,11:54:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.2,13,false,11:54:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.2,13,false,11:54:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.2,13,false,11:54:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.2,14,false,11:54:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.2,13,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.2,14,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.2,14,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
2,0.2,14,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.2,14,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.2,14,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.2,14,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.2,14,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.2,19,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.2,13,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.2,13,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.2,13,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.2,14,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.2,14,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.2,14,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.2,14,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.2,13,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.2,13,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.2,13,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.2,13,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.2,14,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.2,14,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.2,14,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
3,0.2,14,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.2,14,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.2,14,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.2,14,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.2,14,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.2,14,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.2,14,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.2,15,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.2,14,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.2,14,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.2,14,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.2,14,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.2,14,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.2,14,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.2,14,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.2,14,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.2,14,false,11:54:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.2,14,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.2,14,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.2,14,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
4,0.2,14,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.2,14,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.2,14,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.2,14,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.2,14,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.2,14,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.2,14,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.2,14,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.2,14,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.2,15,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.2,14,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.2,14,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.2,14,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.2,15,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.2,14,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.2,14,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.2,14,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.2,14,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.2,14,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.2,14,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
5,0.2,14,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.2,15,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.2,14,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.2,14,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.2,14,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.2,13,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.2,13,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.2,13,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.2,13,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.2,13,true,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.2,13,true,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.2,13,true,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.2,13,true,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.2,14,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.2,14,false,11:54:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.2,15,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
6,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO StartLabel VALUES (0)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
7,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.2,14,false,11:54:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.2,14,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.2,14,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.2,14,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.2,14,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.2,14,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.2,14,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.2,14,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
8,0.2,14,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.2,14,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.2,14,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.2,14,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.2,14,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.2,14,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.2,14,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.2,14,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.2,14,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.2,14,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.2,14,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.2,14,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.2,14,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.2,14,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.2,14,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.2,14,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.2,14,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.2,14,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.2,14,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.2,15,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
9,0.2,14,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.2,16,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.2,16,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.2,16,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.2,16,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.2,14,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.2,14,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.2,14,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.2,16,false,11:54:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.2,15,false,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.2,15,false,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.2,15,false,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.2,15,false,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.2,30,false,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.2,30,false,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.2,30,false,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.2,30,false,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.2,15,false,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.2,15,false,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.2,15,false,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
10,0.2,15,false,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.2,16,false,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.2,17,false,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.2,16,false,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.2,17,false,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.2,14,true,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.2,14,true,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.2,14,true,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.2,14,true,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.2,15,false,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.2,15,false,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.2,15,false,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.2,15,false,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.2,14,false,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 2);
INSERT INTO StartLabel VALUES (9)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.2,14,false,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 2);
INSERT INTO StartLabel VALUES (9)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.2,14,false,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 2);
INSERT INTO StartLabel VALUES (9)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.2,14,false,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 2);
INSERT INTO StartLabel VALUES (9)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.2,15,false,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO A (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.2,14,false,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO A (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.2,15,false,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO A (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
11,0.2,15,false,11:54:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO A (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.2,14,false,11:54:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 11);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.2,14,false,11:54:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 11);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.2,14,false,11:54:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 11);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.2,14,false,11:54:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 11);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.2,14,false,11:54:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO A (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.2,14,false,11:54:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO A (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.2,14,false,11:54:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO A (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.2,14,false,11:54:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO A (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (4)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.2,23,false,11:54:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (11)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.2,23,false,11:54:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (11)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.2,23,false,11:54:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (11)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.2,23,false,11:54:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO StartLabel VALUES (2)
INSERT INTO EndLabel VALUES (11)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.2,15,true,11:54:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (2, 11);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 11);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.2,14,true,11:54:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (2, 11);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 11);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.2,14,true,11:54:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (2, 11);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 11);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.2,14,true,11:54:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (2, 11);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO B (s, t) VALUES (3, 11);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 11);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.2,27,false,11:54:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 11);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.2,28,false,11:54:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 11);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.2,27,false,11:54:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 11);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
12,0.2,28,false,11:54:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 11);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.2,15,false,11:54:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 7);
INSERT INTO A (s, t) VALUES (12, 0);
INSERT INTO B (s, t) VALUES (12, 1);
INSERT INTO A (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 7);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.2,15,false,11:54:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 7);
INSERT INTO A (s, t) VALUES (12, 0);
INSERT INTO B (s, t) VALUES (12, 1);
INSERT INTO A (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 7);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.2,15,false,11:54:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 7);
INSERT INTO A (s, t) VALUES (12, 0);
INSERT INTO B (s, t) VALUES (12, 1);
INSERT INTO A (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 7);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.2,15,false,11:54:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 7);
INSERT INTO A (s, t) VALUES (12, 0);
INSERT INTO B (s, t) VALUES (12, 1);
INSERT INTO A (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 7);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.2,19,false,11:54:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 12);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 12);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.2,20,false,11:54:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 12);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 12);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.2,19,false,11:54:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 12);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 12);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.2,19,false,11:54:48
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 12);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 12);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.2,19,true,11:54:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 2);
INSERT INTO A (s, t) VALUES (11, 4);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (11, 11);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.2,19,true,11:54:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 2);
INSERT INTO A (s, t) VALUES (11, 4);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (11, 11);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.2,20,true,11:54:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 2);
INSERT INTO A (s, t) VALUES (11, 4);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (11, 11);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.2,19,true,11:54:49
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 2);
INSERT INTO A (s, t) VALUES (11, 4);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (11, 11);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.2,69022,false,11:57:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 11);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 12);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 12);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (10, 1);
INSERT INTO B (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (12, 3);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.2,71864,false,11:58:18
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 11);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 12);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 12);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (10, 1);
INSERT INTO B (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (12, 3);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.2,73284,false,11:59:31
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 11);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 12);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 12);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (10, 1);
INSERT INTO B (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (12, 3);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.2,73348,false,12:00:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 11);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 12);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 12);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (10, 1);
INSERT INTO B (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (12, 3);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.2,21,false,12:00:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO A (s, t) VALUES (4, 12);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (7, 12);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 12);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO A (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 12);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.2,22,false,12:00:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO A (s, t) VALUES (4, 12);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (7, 12);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 12);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO A (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 12);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.2,22,false,12:00:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO A (s, t) VALUES (4, 12);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (7, 12);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 12);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO A (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 12);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
13,0.2,22,false,12:00:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO A (s, t) VALUES (4, 12);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (7, 12);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 12);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO A (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 12);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (5)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.2,15,true,12:00:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 13);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (11, 13);
INSERT INTO B (s, t) VALUES (12, 7);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO B (s, t) VALUES (12, 11);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (13, 8);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.2,15,true,12:00:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 13);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (11, 13);
INSERT INTO B (s, t) VALUES (12, 7);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO B (s, t) VALUES (12, 11);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (13, 8);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.2,15,true,12:00:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 13);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (11, 13);
INSERT INTO B (s, t) VALUES (12, 7);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO B (s, t) VALUES (12, 11);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (13, 8);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.2,15,true,12:00:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 13);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (11, 13);
INSERT INTO B (s, t) VALUES (12, 7);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO B (s, t) VALUES (12, 11);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (13, 8);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.2,17,false,12:00:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 13);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (6, 13);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (8, 12);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 12);
INSERT INTO A (s, t) VALUES (10, 13);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO B (s, t) VALUES (13, 9);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.2,17,false,12:00:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 13);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (6, 13);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (8, 12);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 12);
INSERT INTO A (s, t) VALUES (10, 13);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO B (s, t) VALUES (13, 9);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.2,17,false,12:00:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 13);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (6, 13);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (8, 12);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 12);
INSERT INTO A (s, t) VALUES (10, 13);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO B (s, t) VALUES (13, 9);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.2,18,false,12:00:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 13);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (6, 13);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (8, 12);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 12);
INSERT INTO A (s, t) VALUES (10, 13);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO B (s, t) VALUES (13, 9);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.2,72,false,12:00:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 12);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 13);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 12);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO B (s, t) VALUES (8, 12);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 13);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 11);
INSERT INTO A (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO B (s, t) VALUES (11, 13);
INSERT INTO B (s, t) VALUES (12, 1);
INSERT INTO B (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO B (s, t) VALUES (13, 2);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO A (s, t) VALUES (13, 6);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.2,72,false,12:00:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 12);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 13);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 12);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO B (s, t) VALUES (8, 12);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 13);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 11);
INSERT INTO A (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO B (s, t) VALUES (11, 13);
INSERT INTO B (s, t) VALUES (12, 1);
INSERT INTO B (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO B (s, t) VALUES (13, 2);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO A (s, t) VALUES (13, 6);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.2,72,false,12:00:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 12);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 13);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 12);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO B (s, t) VALUES (8, 12);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 13);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 11);
INSERT INTO A (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO B (s, t) VALUES (11, 13);
INSERT INTO B (s, t) VALUES (12, 1);
INSERT INTO B (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO B (s, t) VALUES (13, 2);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO A (s, t) VALUES (13, 6);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.2,70,false,12:00:45
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 12);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 13);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 12);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO B (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO B (s, t) VALUES (8, 12);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 13);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 11);
INSERT INTO A (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 8);
INSERT INTO B (s, t) VALUES (11, 13);
INSERT INTO B (s, t) VALUES (12, 1);
INSERT INTO B (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO B (s, t) VALUES (13, 2);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO A (s, t) VALUES (13, 6);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.2,325,false,12:00:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (0, 12);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 13);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 12);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO A (s, t) VALUES (10, 13);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 12);
INSERT INTO A (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 11);
INSERT INTO B (s, t) VALUES (13, 3);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO A (s, t) VALUES (13, 8);
INSERT INTO StartLabel VALUES (13)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.2,326,false,12:00:46
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (0, 12);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 13);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 12);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO A (s, t) VALUES (10, 13);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 12);
INSERT INTO A (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 11);
INSERT INTO B (s, t) VALUES (13, 3);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO A (s, t) VALUES (13, 8);
INSERT INTO StartLabel VALUES (13)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.2,326,false,12:00:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (0, 12);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 13);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 12);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO A (s, t) VALUES (10, 13);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 12);
INSERT INTO A (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 11);
INSERT INTO B (s, t) VALUES (13, 3);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO A (s, t) VALUES (13, 8);
INSERT INTO StartLabel VALUES (13)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.2,325,false,12:00:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (0, 12);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 13);
INSERT INTO B (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 12);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO A (s, t) VALUES (10, 13);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 12);
INSERT INTO A (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 11);
INSERT INTO B (s, t) VALUES (13, 3);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO A (s, t) VALUES (13, 8);
INSERT INTO StartLabel VALUES (13)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.2,14,false,12:00:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (1, 13);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 11);
INSERT INTO B (s, t) VALUES (13, 6);
INSERT INTO A (s, t) VALUES (13, 7);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.2,14,false,12:00:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (1, 13);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 11);
INSERT INTO B (s, t) VALUES (13, 6);
INSERT INTO A (s, t) VALUES (13, 7);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.2,14,false,12:00:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (1, 13);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 11);
INSERT INTO B (s, t) VALUES (13, 6);
INSERT INTO A (s, t) VALUES (13, 7);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
14,0.2,14,false,12:00:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (1, 13);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 11);
INSERT INTO B (s, t) VALUES (13, 6);
INSERT INTO A (s, t) VALUES (13, 7);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.2,218023,false,12:08:02
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (2, 14);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO A (s, t) VALUES (5, 13);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (6, 14);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 13);
INSERT INTO B (s, t) VALUES (8, 14);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 14);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO A (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO A (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (12, 14);
INSERT INTO A (s, t) VALUES (13, 1);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (13, 9);
INSERT INTO B (s, t) VALUES (13, 12);
INSERT INTO B (s, t) VALUES (14, 5);
INSERT INTO B (s, t) VALUES (14, 6);
INSERT INTO A (s, t) VALUES (14, 13);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (12)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.2,217896,false,12:11:40
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (2, 14);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO A (s, t) VALUES (5, 13);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (6, 14);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 13);
INSERT INTO B (s, t) VALUES (8, 14);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 14);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO A (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO A (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (12, 14);
INSERT INTO A (s, t) VALUES (13, 1);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (13, 9);
INSERT INTO B (s, t) VALUES (13, 12);
INSERT INTO B (s, t) VALUES (14, 5);
INSERT INTO B (s, t) VALUES (14, 6);
INSERT INTO A (s, t) VALUES (14, 13);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (12)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.2,217864,false,12:15:18
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (2, 14);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO A (s, t) VALUES (5, 13);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (6, 14);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 13);
INSERT INTO B (s, t) VALUES (8, 14);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 14);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO A (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO A (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (12, 14);
INSERT INTO A (s, t) VALUES (13, 1);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (13, 9);
INSERT INTO B (s, t) VALUES (13, 12);
INSERT INTO B (s, t) VALUES (14, 5);
INSERT INTO B (s, t) VALUES (14, 6);
INSERT INTO A (s, t) VALUES (14, 13);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (12)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.2,217973,false,12:18:56
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (2, 14);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO B (s, t) VALUES (4, 3);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO A (s, t) VALUES (5, 13);
INSERT INTO A (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (6, 14);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 13);
INSERT INTO B (s, t) VALUES (8, 14);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 14);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO B (s, t) VALUES (10, 8);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO A (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO A (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (12, 14);
INSERT INTO A (s, t) VALUES (13, 1);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (13, 9);
INSERT INTO B (s, t) VALUES (13, 12);
INSERT INTO B (s, t) VALUES (14, 5);
INSERT INTO B (s, t) VALUES (14, 6);
INSERT INTO A (s, t) VALUES (14, 13);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (12)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.2,17,false,12:18:56
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO B (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (7, 12);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (10, 14);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (11, 13);
INSERT INTO A (s, t) VALUES (11, 14);
INSERT INTO B (s, t) VALUES (13, 3);
INSERT INTO B (s, t) VALUES (13, 5);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (14, 1);
INSERT INTO B (s, t) VALUES (14, 5);
INSERT INTO B (s, t) VALUES (14, 10);
INSERT INTO A (s, t) VALUES (14, 14);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.2,17,false,12:18:56
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO B (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (7, 12);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (10, 14);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (11, 13);
INSERT INTO A (s, t) VALUES (11, 14);
INSERT INTO B (s, t) VALUES (13, 3);
INSERT INTO B (s, t) VALUES (13, 5);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (14, 1);
INSERT INTO B (s, t) VALUES (14, 5);
INSERT INTO B (s, t) VALUES (14, 10);
INSERT INTO A (s, t) VALUES (14, 14);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.2,17,false,12:18:56
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO B (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (7, 12);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (10, 14);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (11, 13);
INSERT INTO A (s, t) VALUES (11, 14);
INSERT INTO B (s, t) VALUES (13, 3);
INSERT INTO B (s, t) VALUES (13, 5);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (14, 1);
INSERT INTO B (s, t) VALUES (14, 5);
INSERT INTO B (s, t) VALUES (14, 10);
INSERT INTO A (s, t) VALUES (14, 14);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.2,17,false,12:18:56
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO B (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 2);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (7, 12);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (10, 14);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (11, 13);
INSERT INTO A (s, t) VALUES (11, 14);
INSERT INTO B (s, t) VALUES (13, 3);
INSERT INTO B (s, t) VALUES (13, 5);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (14, 1);
INSERT INTO B (s, t) VALUES (14, 5);
INSERT INTO B (s, t) VALUES (14, 10);
INSERT INTO A (s, t) VALUES (14, 14);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.2,135,false,12:18:56
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (2, 14);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO A (s, t) VALUES (3, 14);
INSERT INTO B (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (7, 12);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 14);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (10, 14);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO A (s, t) VALUES (11, 5);
INSERT INTO A (s, t) VALUES (11, 13);
INSERT INTO A (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 3);
INSERT INTO A (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO A (s, t) VALUES (12, 14);
INSERT INTO B (s, t) VALUES (13, 1);
INSERT INTO A (s, t) VALUES (13, 3);
INSERT INTO B (s, t) VALUES (13, 10);
INSERT INTO B (s, t) VALUES (13, 13);
INSERT INTO A (s, t) VALUES (14, 1);
INSERT INTO A (s, t) VALUES (14, 13);
INSERT INTO StartLabel VALUES (9)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.2,135,false,12:18:56
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (2, 14);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO A (s, t) VALUES (3, 14);
INSERT INTO B (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (7, 12);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 14);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (10, 14);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO A (s, t) VALUES (11, 5);
INSERT INTO A (s, t) VALUES (11, 13);
INSERT INTO A (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 3);
INSERT INTO A (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO A (s, t) VALUES (12, 14);
INSERT INTO B (s, t) VALUES (13, 1);
INSERT INTO A (s, t) VALUES (13, 3);
INSERT INTO B (s, t) VALUES (13, 10);
INSERT INTO B (s, t) VALUES (13, 13);
INSERT INTO A (s, t) VALUES (14, 1);
INSERT INTO A (s, t) VALUES (14, 13);
INSERT INTO StartLabel VALUES (9)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.2,134,false,12:18:57
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (2, 14);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO A (s, t) VALUES (3, 14);
INSERT INTO B (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (7, 12);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 14);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (10, 14);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO A (s, t) VALUES (11, 5);
INSERT INTO A (s, t) VALUES (11, 13);
INSERT INTO A (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 3);
INSERT INTO A (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO A (s, t) VALUES (12, 14);
INSERT INTO B (s, t) VALUES (13, 1);
INSERT INTO A (s, t) VALUES (13, 3);
INSERT INTO B (s, t) VALUES (13, 10);
INSERT INTO B (s, t) VALUES (13, 13);
INSERT INTO A (s, t) VALUES (14, 1);
INSERT INTO A (s, t) VALUES (14, 13);
INSERT INTO StartLabel VALUES (9)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.2,135,false,12:18:57
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (2, 14);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO A (s, t) VALUES (3, 14);
INSERT INTO B (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (7, 12);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 14);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (10, 14);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO A (s, t) VALUES (11, 5);
INSERT INTO A (s, t) VALUES (11, 13);
INSERT INTO A (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 3);
INSERT INTO A (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO A (s, t) VALUES (12, 14);
INSERT INTO B (s, t) VALUES (13, 1);
INSERT INTO A (s, t) VALUES (13, 3);
INSERT INTO B (s, t) VALUES (13, 10);
INSERT INTO B (s, t) VALUES (13, 13);
INSERT INTO A (s, t) VALUES (14, 1);
INSERT INTO A (s, t) VALUES (14, 13);
INSERT INTO StartLabel VALUES (9)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.2,30,false,12:18:57
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 12);
INSERT INTO B (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (2, 14);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (8, 12);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (10, 13);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO A (s, t) VALUES (12, 7);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO B (s, t) VALUES (12, 11);
INSERT INTO A (s, t) VALUES (12, 14);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO A (s, t) VALUES (13, 7);
INSERT INTO A (s, t) VALUES (14, 3);
INSERT INTO A (s, t) VALUES (14, 4);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (12)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.2,30,false,12:18:57
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 12);
INSERT INTO B (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (2, 14);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (8, 12);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (10, 13);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO A (s, t) VALUES (12, 7);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO B (s, t) VALUES (12, 11);
INSERT INTO A (s, t) VALUES (12, 14);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO A (s, t) VALUES (13, 7);
INSERT INTO A (s, t) VALUES (14, 3);
INSERT INTO A (s, t) VALUES (14, 4);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (12)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.2,31,false,12:18:57
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 12);
INSERT INTO B (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (2, 14);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (8, 12);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (10, 13);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO A (s, t) VALUES (12, 7);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO B (s, t) VALUES (12, 11);
INSERT INTO A (s, t) VALUES (12, 14);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO A (s, t) VALUES (13, 7);
INSERT INTO A (s, t) VALUES (14, 3);
INSERT INTO A (s, t) VALUES (14, 4);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (12)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.2,30,false,12:18:57
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 12);
INSERT INTO B (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (2, 14);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (8, 12);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (10, 13);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO A (s, t) VALUES (12, 7);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO B (s, t) VALUES (12, 11);
INSERT INTO A (s, t) VALUES (12, 14);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO A (s, t) VALUES (13, 7);
INSERT INTO A (s, t) VALUES (14, 3);
INSERT INTO A (s, t) VALUES (14, 4);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (12)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.2,39,false,12:18:57
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO A (s, t) VALUES (3, 14);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 12);
INSERT INTO B (s, t) VALUES (8, 14);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 13);
INSERT INTO A (s, t) VALUES (12, 8);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (14, 0);
INSERT INTO A (s, t) VALUES (14, 13);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.2,39,false,12:18:57
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO A (s, t) VALUES (3, 14);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 12);
INSERT INTO B (s, t) VALUES (8, 14);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 13);
INSERT INTO A (s, t) VALUES (12, 8);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (14, 0);
INSERT INTO A (s, t) VALUES (14, 13);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.2,40,false,12:18:57
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO A (s, t) VALUES (3, 14);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 12);
INSERT INTO B (s, t) VALUES (8, 14);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 13);
INSERT INTO A (s, t) VALUES (12, 8);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (14, 0);
INSERT INTO A (s, t) VALUES (14, 13);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
15,0.2,39,false,12:18:57
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO B (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO A (s, t) VALUES (3, 14);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO A (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 12);
INSERT INTO B (s, t) VALUES (8, 14);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 13);
INSERT INTO A (s, t) VALUES (12, 8);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (14, 0);
INSERT INTO A (s, t) VALUES (14, 13);
INSERT INTO StartLabel VALUES (1)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
16,0.2,18,false,12:18:57
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO A (s, t) VALUES (3, 13);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO A (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (4, 12);
INSERT INTO A (s, t) VALUES (4, 14);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 15);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 14);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 13);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO B (s, t) VALUES (13, 7);
INSERT INTO B (s, t) VALUES (13, 9);
INSERT INTO A (s, t) VALUES (14, 0);
INSERT INTO B (s, t) VALUES (14, 2);
INSERT INTO B (s, t) VALUES (14, 6);
INSERT INTO B (s, t) VALUES (14, 13);
INSERT INTO A (s, t) VALUES (14, 15);
INSERT INTO A (s, t) VALUES (15, 2);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
16,0.2,18,false,12:18:57
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO A (s, t) VALUES (3, 13);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO A (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (4, 12);
INSERT INTO A (s, t) VALUES (4, 14);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 15);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 14);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 13);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO B (s, t) VALUES (13, 7);
INSERT INTO B (s, t) VALUES (13, 9);
INSERT INTO A (s, t) VALUES (14, 0);
INSERT INTO B (s, t) VALUES (14, 2);
INSERT INTO B (s, t) VALUES (14, 6);
INSERT INTO B (s, t) VALUES (14, 13);
INSERT INTO A (s, t) VALUES (14, 15);
INSERT INTO A (s, t) VALUES (15, 2);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
16,0.2,18,false,12:18:57
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO A (s, t) VALUES (3, 13);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO A (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (4, 12);
INSERT INTO A (s, t) VALUES (4, 14);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 15);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 14);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 13);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO B (s, t) VALUES (13, 7);
INSERT INTO B (s, t) VALUES (13, 9);
INSERT INTO A (s, t) VALUES (14, 0);
INSERT INTO B (s, t) VALUES (14, 2);
INSERT INTO B (s, t) VALUES (14, 6);
INSERT INTO B (s, t) VALUES (14, 13);
INSERT INTO A (s, t) VALUES (14, 15);
INSERT INTO A (s, t) VALUES (15, 2);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
16,0.2,18,false,12:18:57
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO A (s, t) VALUES (3, 13);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO A (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (4, 12);
INSERT INTO A (s, t) VALUES (4, 14);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 15);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 14);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 13);
INSERT INTO B (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (10, 5);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO B (s, t) VALUES (13, 7);
INSERT INTO B (s, t) VALUES (13, 9);
INSERT INTO A (s, t) VALUES (14, 0);
INSERT INTO B (s, t) VALUES (14, 2);
INSERT INTO B (s, t) VALUES (14, 6);
INSERT INTO B (s, t) VALUES (14, 13);
INSERT INTO A (s, t) VALUES (14, 15);
INSERT INTO A (s, t) VALUES (15, 2);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
16,0.2,16,true,12:18:57
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (1, 15);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (7, 14);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO B (s, t) VALUES (12, 7);
INSERT INTO A (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (13, 2);
INSERT INTO B (s, t) VALUES (13, 11);
INSERT INTO B (s, t) VALUES (13, 14);
INSERT INTO A (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (15, 2);
INSERT INTO B (s, t) VALUES (15, 7);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (12)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
16,0.2,15,true,12:18:57
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (1, 15);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (7, 14);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO B (s, t) VALUES (12, 7);
INSERT INTO A (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (13, 2);
INSERT INTO B (s, t) VALUES (13, 11);
INSERT INTO B (s, t) VALUES (13, 14);
INSERT INTO A (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (15, 2);
INSERT INTO B (s, t) VALUES (15, 7);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (12)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
16,0.2,15,true,12:18:57
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (1, 15);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (7, 14);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO B (s, t) VALUES (12, 7);
INSERT INTO A (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (13, 2);
INSERT INTO B (s, t) VALUES (13, 11);
INSERT INTO B (s, t) VALUES (13, 14);
INSERT INTO A (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (15, 2);
INSERT INTO B (s, t) VALUES (15, 7);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (12)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
16,0.2,15,true,12:18:57
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (1, 15);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (7, 14);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO B (s, t) VALUES (12, 7);
INSERT INTO A (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (13, 2);
INSERT INTO B (s, t) VALUES (13, 11);
INSERT INTO B (s, t) VALUES (13, 14);
INSERT INTO A (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (15, 2);
INSERT INTO B (s, t) VALUES (15, 7);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (12)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
16,0.2,21,false,12:18:58
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 12);
INSERT INTO A (s, t) VALUES (1, 15);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO B (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 15);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 14);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 4);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 8);
INSERT INTO B (s, t) VALUES (11, 10);
INSERT INTO A (s, t) VALUES (11, 15);
INSERT INTO B (s, t) VALUES (12, 1);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (13, 13);
INSERT INTO A (s, t) VALUES (13, 15);
INSERT INTO B (s, t) VALUES (14, 1);
INSERT INTO B (s, t) VALUES (14, 2);
INSERT INTO A (s, t) VALUES (14, 12);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 4);
INSERT INTO A (s, t) VALUES (15, 8);
INSERT INTO B (s, t) VALUES (15, 14);
INSERT INTO StartLabel VALUES (15)
INSERT INTO EndLabel VALUES (13)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
16,0.2,21,false,12:18:58
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 12);
INSERT INTO A (s, t) VALUES (1, 15);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO B (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 15);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 14);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 4);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 8);
INSERT INTO B (s, t) VALUES (11, 10);
INSERT INTO A (s, t) VALUES (11, 15);
INSERT INTO B (s, t) VALUES (12, 1);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (13, 13);
INSERT INTO A (s, t) VALUES (13, 15);
INSERT INTO B (s, t) VALUES (14, 1);
INSERT INTO B (s, t) VALUES (14, 2);
INSERT INTO A (s, t) VALUES (14, 12);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 4);
INSERT INTO A (s, t) VALUES (15, 8);
INSERT INTO B (s, t) VALUES (15, 14);
INSERT INTO StartLabel VALUES (15)
INSERT INTO EndLabel VALUES (13)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
16,0.2,22,false,12:18:58
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 12);
INSERT INTO A (s, t) VALUES (1, 15);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO B (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 15);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 14);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 4);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 8);
INSERT INTO B (s, t) VALUES (11, 10);
INSERT INTO A (s, t) VALUES (11, 15);
INSERT INTO B (s, t) VALUES (12, 1);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (13, 13);
INSERT INTO A (s, t) VALUES (13, 15);
INSERT INTO B (s, t) VALUES (14, 1);
INSERT INTO B (s, t) VALUES (14, 2);
INSERT INTO A (s, t) VALUES (14, 12);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 4);
INSERT INTO A (s, t) VALUES (15, 8);
INSERT INTO B (s, t) VALUES (15, 14);
INSERT INTO StartLabel VALUES (15)
INSERT INTO EndLabel VALUES (13)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
16,0.2,22,false,12:18:58
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 12);
INSERT INTO A (s, t) VALUES (1, 15);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO B (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (5, 2);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (6, 2);
INSERT INTO B (s, t) VALUES (6, 15);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (8, 4);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO B (s, t) VALUES (10, 14);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 4);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 8);
INSERT INTO B (s, t) VALUES (11, 10);
INSERT INTO A (s, t) VALUES (11, 15);
INSERT INTO B (s, t) VALUES (12, 1);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (13, 13);
INSERT INTO A (s, t) VALUES (13, 15);
INSERT INTO B (s, t) VALUES (14, 1);
INSERT INTO B (s, t) VALUES (14, 2);
INSERT INTO A (s, t) VALUES (14, 12);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 4);
INSERT INTO A (s, t) VALUES (15, 8);
INSERT INTO B (s, t) VALUES (15, 14);
INSERT INTO StartLabel VALUES (15)
INSERT INTO EndLabel VALUES (13)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
16,0.2,20,true,12:18:58
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 15);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (1, 13);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (4, 15);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (6, 15);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (7, 13);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (10, 13);
INSERT INTO A (s, t) VALUES (11, 2);
INSERT INTO B (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (12, 15);
INSERT INTO A (s, t) VALUES (13, 2);
INSERT INTO A (s, t) VALUES (13, 6);
INSERT INTO A (s, t) VALUES (13, 12);
INSERT INTO A (s, t) VALUES (13, 13);
INSERT INTO B (s, t) VALUES (13, 15);
INSERT INTO A (s, t) VALUES (14, 3);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO A (s, t) VALUES (14, 5);
INSERT INTO B (s, t) VALUES (15, 3);
INSERT INTO A (s, t) VALUES (15, 5);
INSERT INTO A (s, t) VALUES (15, 11);
INSERT INTO A (s, t) VALUES (15, 12);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (12)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
16,0.2,21,true,12:18:58
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 15);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (1, 13);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (4, 15);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (6, 15);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (7, 13);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (10, 13);
INSERT INTO A (s, t) VALUES (11, 2);
INSERT INTO B (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (12, 15);
INSERT INTO A (s, t) VALUES (13, 2);
INSERT INTO A (s, t) VALUES (13, 6);
INSERT INTO A (s, t) VALUES (13, 12);
INSERT INTO A (s, t) VALUES (13, 13);
INSERT INTO B (s, t) VALUES (13, 15);
INSERT INTO A (s, t) VALUES (14, 3);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO A (s, t) VALUES (14, 5);
INSERT INTO B (s, t) VALUES (15, 3);
INSERT INTO A (s, t) VALUES (15, 5);
INSERT INTO A (s, t) VALUES (15, 11);
INSERT INTO A (s, t) VALUES (15, 12);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (12)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
16,0.2,21,true,12:18:58
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 15);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (1, 13);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (4, 15);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (6, 15);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (7, 13);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (10, 13);
INSERT INTO A (s, t) VALUES (11, 2);
INSERT INTO B (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (12, 15);
INSERT INTO A (s, t) VALUES (13, 2);
INSERT INTO A (s, t) VALUES (13, 6);
INSERT INTO A (s, t) VALUES (13, 12);
INSERT INTO A (s, t) VALUES (13, 13);
INSERT INTO B (s, t) VALUES (13, 15);
INSERT INTO A (s, t) VALUES (14, 3);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO A (s, t) VALUES (14, 5);
INSERT INTO B (s, t) VALUES (15, 3);
INSERT INTO A (s, t) VALUES (15, 5);
INSERT INTO A (s, t) VALUES (15, 11);
INSERT INTO A (s, t) VALUES (15, 12);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (12)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
16,0.2,21,true,12:18:58
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 15);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (1, 13);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO B (s, t) VALUES (4, 1);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (4, 15);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (6, 15);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (7, 13);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (10, 13);
INSERT INTO A (s, t) VALUES (11, 2);
INSERT INTO B (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (12, 15);
INSERT INTO A (s, t) VALUES (13, 2);
INSERT INTO A (s, t) VALUES (13, 6);
INSERT INTO A (s, t) VALUES (13, 12);
INSERT INTO A (s, t) VALUES (13, 13);
INSERT INTO B (s, t) VALUES (13, 15);
INSERT INTO A (s, t) VALUES (14, 3);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO A (s, t) VALUES (14, 5);
INSERT INTO B (s, t) VALUES (15, 3);
INSERT INTO A (s, t) VALUES (15, 5);
INSERT INTO A (s, t) VALUES (15, 11);
INSERT INTO A (s, t) VALUES (15, 12);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (12)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
16,0.2,3038,false,12:19:04
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (0, 15);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 14);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 15);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 13);
INSERT INTO A (s, t) VALUES (11, 8);
INSERT INTO A (s, t) VALUES (11, 15);
INSERT INTO A (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 14);
INSERT INTO A (s, t) VALUES (13, 3);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO A (s, t) VALUES (13, 9);
INSERT INTO A (s, t) VALUES (14, 0);
INSERT INTO B (s, t) VALUES (14, 2);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 5);
INSERT INTO A (s, t) VALUES (14, 12);
INSERT INTO B (s, t) VALUES (14, 14);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 2);
INSERT INTO A (s, t) VALUES (15, 7);
INSERT INTO A (s, t) VALUES (15, 10);
INSERT INTO A (s, t) VALUES (15, 13);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (11)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
16,0.2,3005,false,12:19:07
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (0, 15);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 14);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 15);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 13);
INSERT INTO A (s, t) VALUES (11, 8);
INSERT INTO A (s, t) VALUES (11, 15);
INSERT INTO A (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 14);
INSERT INTO A (s, t) VALUES (13, 3);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO A (s, t) VALUES (13, 9);
INSERT INTO A (s, t) VALUES (14, 0);
INSERT INTO B (s, t) VALUES (14, 2);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 5);
INSERT INTO A (s, t) VALUES (14, 12);
INSERT INTO B (s, t) VALUES (14, 14);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 2);
INSERT INTO A (s, t) VALUES (15, 7);
INSERT INTO A (s, t) VALUES (15, 10);
INSERT INTO A (s, t) VALUES (15, 13);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (11)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
16,0.2,3006,false,12:19:10
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (0, 15);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 14);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 15);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 13);
INSERT INTO A (s, t) VALUES (11, 8);
INSERT INTO A (s, t) VALUES (11, 15);
INSERT INTO A (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 14);
INSERT INTO A (s, t) VALUES (13, 3);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO A (s, t) VALUES (13, 9);
INSERT INTO A (s, t) VALUES (14, 0);
INSERT INTO B (s, t) VALUES (14, 2);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 5);
INSERT INTO A (s, t) VALUES (14, 12);
INSERT INTO B (s, t) VALUES (14, 14);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 2);
INSERT INTO A (s, t) VALUES (15, 7);
INSERT INTO A (s, t) VALUES (15, 10);
INSERT INTO A (s, t) VALUES (15, 13);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (11)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
16,0.2,3032,false,12:19:13
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (0, 15);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 14);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 6);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 15);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (10, 13);
INSERT INTO A (s, t) VALUES (11, 8);
INSERT INTO A (s, t) VALUES (11, 15);
INSERT INTO A (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 8);
INSERT INTO B (s, t) VALUES (12, 14);
INSERT INTO A (s, t) VALUES (13, 3);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO A (s, t) VALUES (13, 9);
INSERT INTO A (s, t) VALUES (14, 0);
INSERT INTO B (s, t) VALUES (14, 2);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 5);
INSERT INTO A (s, t) VALUES (14, 12);
INSERT INTO B (s, t) VALUES (14, 14);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 2);
INSERT INTO A (s, t) VALUES (15, 7);
INSERT INTO A (s, t) VALUES (15, 10);
INSERT INTO A (s, t) VALUES (15, 13);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (11)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
17,0.2,timeout,false,12:29:13
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (0, 12);
INSERT INTO B (s, t) VALUES (0, 15);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 12);
INSERT INTO B (s, t) VALUES (1, 15);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 11);
INSERT INTO A (s, t) VALUES (2, 16);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO B (s, t) VALUES (5, 16);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (6, 12);
INSERT INTO B (s, t) VALUES (6, 13);
INSERT INTO A (s, t) VALUES (6, 15);
INSERT INTO B (s, t) VALUES (6, 16);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (7, 14);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (8, 11);
INSERT INTO A (s, t) VALUES (8, 13);
INSERT INTO B (s, t) VALUES (8, 14);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 11);
INSERT INTO A (s, t) VALUES (10, 12);
INSERT INTO A (s, t) VALUES (10, 14);
INSERT INTO A (s, t) VALUES (10, 15);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 13);
INSERT INTO A (s, t) VALUES (11, 15);
INSERT INTO B (s, t) VALUES (12, 15);
INSERT INTO B (s, t) VALUES (13, 2);
INSERT INTO B (s, t) VALUES (13, 5);
INSERT INTO B (s, t) VALUES (13, 10);
INSERT INTO B (s, t) VALUES (13, 12);
INSERT INTO B (s, t) VALUES (14, 3);
INSERT INTO A (s, t) VALUES (14, 8);
INSERT INTO B (s, t) VALUES (14, 10);
INSERT INTO B (s, t) VALUES (14, 12);
INSERT INTO A (s, t) VALUES (15, 11);
INSERT INTO A (s, t) VALUES (16, 1);
INSERT INTO A (s, t) VALUES (16, 9);
INSERT INTO A (s, t) VALUES (16, 10);
INSERT INTO A (s, t) VALUES (16, 12);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
17,0.2,timeout,false,12:34:13
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (0, 12);
INSERT INTO B (s, t) VALUES (0, 15);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 12);
INSERT INTO B (s, t) VALUES (1, 15);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 11);
INSERT INTO A (s, t) VALUES (2, 16);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO B (s, t) VALUES (5, 16);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (6, 12);
INSERT INTO B (s, t) VALUES (6, 13);
INSERT INTO A (s, t) VALUES (6, 15);
INSERT INTO B (s, t) VALUES (6, 16);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (7, 14);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (8, 11);
INSERT INTO A (s, t) VALUES (8, 13);
INSERT INTO B (s, t) VALUES (8, 14);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 11);
INSERT INTO A (s, t) VALUES (10, 12);
INSERT INTO A (s, t) VALUES (10, 14);
INSERT INTO A (s, t) VALUES (10, 15);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 13);
INSERT INTO A (s, t) VALUES (11, 15);
INSERT INTO B (s, t) VALUES (12, 15);
INSERT INTO B (s, t) VALUES (13, 2);
INSERT INTO B (s, t) VALUES (13, 5);
INSERT INTO B (s, t) VALUES (13, 10);
INSERT INTO B (s, t) VALUES (13, 12);
INSERT INTO B (s, t) VALUES (14, 3);
INSERT INTO A (s, t) VALUES (14, 8);
INSERT INTO B (s, t) VALUES (14, 10);
INSERT INTO B (s, t) VALUES (14, 12);
INSERT INTO A (s, t) VALUES (15, 11);
INSERT INTO A (s, t) VALUES (16, 1);
INSERT INTO A (s, t) VALUES (16, 9);
INSERT INTO A (s, t) VALUES (16, 10);
INSERT INTO A (s, t) VALUES (16, 12);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
17,0.2,timeout,false,12:39:13
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (0, 12);
INSERT INTO B (s, t) VALUES (0, 15);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 12);
INSERT INTO B (s, t) VALUES (1, 15);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 11);
INSERT INTO A (s, t) VALUES (2, 16);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO B (s, t) VALUES (5, 16);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (6, 12);
INSERT INTO B (s, t) VALUES (6, 13);
INSERT INTO A (s, t) VALUES (6, 15);
INSERT INTO B (s, t) VALUES (6, 16);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (7, 14);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (8, 11);
INSERT INTO A (s, t) VALUES (8, 13);
INSERT INTO B (s, t) VALUES (8, 14);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 11);
INSERT INTO A (s, t) VALUES (10, 12);
INSERT INTO A (s, t) VALUES (10, 14);
INSERT INTO A (s, t) VALUES (10, 15);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 13);
INSERT INTO A (s, t) VALUES (11, 15);
INSERT INTO B (s, t) VALUES (12, 15);
INSERT INTO B (s, t) VALUES (13, 2);
INSERT INTO B (s, t) VALUES (13, 5);
INSERT INTO B (s, t) VALUES (13, 10);
INSERT INTO B (s, t) VALUES (13, 12);
INSERT INTO B (s, t) VALUES (14, 3);
INSERT INTO A (s, t) VALUES (14, 8);
INSERT INTO B (s, t) VALUES (14, 10);
INSERT INTO B (s, t) VALUES (14, 12);
INSERT INTO A (s, t) VALUES (15, 11);
INSERT INTO A (s, t) VALUES (16, 1);
INSERT INTO A (s, t) VALUES (16, 9);
INSERT INTO A (s, t) VALUES (16, 10);
INSERT INTO A (s, t) VALUES (16, 12);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
17,0.2,timeout,false,12:44:13
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (0, 12);
INSERT INTO B (s, t) VALUES (0, 15);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 12);
INSERT INTO B (s, t) VALUES (1, 15);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 11);
INSERT INTO A (s, t) VALUES (2, 16);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 11);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO B (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO B (s, t) VALUES (5, 16);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (6, 12);
INSERT INTO B (s, t) VALUES (6, 13);
INSERT INTO A (s, t) VALUES (6, 15);
INSERT INTO B (s, t) VALUES (6, 16);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (7, 9);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (7, 14);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (8, 11);
INSERT INTO A (s, t) VALUES (8, 13);
INSERT INTO B (s, t) VALUES (8, 14);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 11);
INSERT INTO A (s, t) VALUES (10, 12);
INSERT INTO A (s, t) VALUES (10, 14);
INSERT INTO A (s, t) VALUES (10, 15);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 13);
INSERT INTO A (s, t) VALUES (11, 15);
INSERT INTO B (s, t) VALUES (12, 15);
INSERT INTO B (s, t) VALUES (13, 2);
INSERT INTO B (s, t) VALUES (13, 5);
INSERT INTO B (s, t) VALUES (13, 10);
INSERT INTO B (s, t) VALUES (13, 12);
INSERT INTO B (s, t) VALUES (14, 3);
INSERT INTO A (s, t) VALUES (14, 8);
INSERT INTO B (s, t) VALUES (14, 10);
INSERT INTO B (s, t) VALUES (14, 12);
INSERT INTO A (s, t) VALUES (15, 11);
INSERT INTO A (s, t) VALUES (16, 1);
INSERT INTO A (s, t) VALUES (16, 9);
INSERT INTO A (s, t) VALUES (16, 10);
INSERT INTO A (s, t) VALUES (16, 12);
INSERT INTO StartLabel VALUES (5)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
17,0.2,267,true,12:44:14
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 11);
INSERT INTO B (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 16);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (3, 16);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (4, 15);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (5, 16);
INSERT INTO A (s, t) VALUES (6, 14);
INSERT INTO B (s, t) VALUES (6, 16);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (10, 16);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO B (s, t) VALUES (11, 16);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO B (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO A (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (13, 7);
INSERT INTO B (s, t) VALUES (13, 9);
INSERT INTO A (s, t) VALUES (13, 14);
INSERT INTO B (s, t) VALUES (14, 3);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO A (s, t) VALUES (14, 6);
INSERT INTO A (s, t) VALUES (14, 9);
INSERT INTO A (s, t) VALUES (14, 10);
INSERT INTO A (s, t) VALUES (14, 11);
INSERT INTO A (s, t) VALUES (15, 1);
INSERT INTO A (s, t) VALUES (15, 8);
INSERT INTO B (s, t) VALUES (16, 2);
INSERT INTO A (s, t) VALUES (16, 3);
INSERT INTO A (s, t) VALUES (16, 5);
INSERT INTO A (s, t) VALUES (16, 9);
INSERT INTO A (s, t) VALUES (16, 14);
INSERT INTO B (s, t) VALUES (16, 15);
INSERT INTO StartLabel VALUES (16)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
17,0.2,266,true,12:44:14
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 11);
INSERT INTO B (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 16);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (3, 16);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (4, 15);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (5, 16);
INSERT INTO A (s, t) VALUES (6, 14);
INSERT INTO B (s, t) VALUES (6, 16);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (10, 16);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO B (s, t) VALUES (11, 16);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO B (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO A (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (13, 7);
INSERT INTO B (s, t) VALUES (13, 9);
INSERT INTO A (s, t) VALUES (13, 14);
INSERT INTO B (s, t) VALUES (14, 3);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO A (s, t) VALUES (14, 6);
INSERT INTO A (s, t) VALUES (14, 9);
INSERT INTO A (s, t) VALUES (14, 10);
INSERT INTO A (s, t) VALUES (14, 11);
INSERT INTO A (s, t) VALUES (15, 1);
INSERT INTO A (s, t) VALUES (15, 8);
INSERT INTO B (s, t) VALUES (16, 2);
INSERT INTO A (s, t) VALUES (16, 3);
INSERT INTO A (s, t) VALUES (16, 5);
INSERT INTO A (s, t) VALUES (16, 9);
INSERT INTO A (s, t) VALUES (16, 14);
INSERT INTO B (s, t) VALUES (16, 15);
INSERT INTO StartLabel VALUES (16)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
17,0.2,267,true,12:44:14
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 11);
INSERT INTO B (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 16);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (3, 16);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (4, 15);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (5, 16);
INSERT INTO A (s, t) VALUES (6, 14);
INSERT INTO B (s, t) VALUES (6, 16);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (10, 16);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO B (s, t) VALUES (11, 16);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO B (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO A (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (13, 7);
INSERT INTO B (s, t) VALUES (13, 9);
INSERT INTO A (s, t) VALUES (13, 14);
INSERT INTO B (s, t) VALUES (14, 3);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO A (s, t) VALUES (14, 6);
INSERT INTO A (s, t) VALUES (14, 9);
INSERT INTO A (s, t) VALUES (14, 10);
INSERT INTO A (s, t) VALUES (14, 11);
INSERT INTO A (s, t) VALUES (15, 1);
INSERT INTO A (s, t) VALUES (15, 8);
INSERT INTO B (s, t) VALUES (16, 2);
INSERT INTO A (s, t) VALUES (16, 3);
INSERT INTO A (s, t) VALUES (16, 5);
INSERT INTO A (s, t) VALUES (16, 9);
INSERT INTO A (s, t) VALUES (16, 14);
INSERT INTO B (s, t) VALUES (16, 15);
INSERT INTO StartLabel VALUES (16)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
17,0.2,266,true,12:44:14
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 11);
INSERT INTO B (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 6);
INSERT INTO B (s, t) VALUES (2, 16);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (3, 16);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (4, 15);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (5, 16);
INSERT INTO A (s, t) VALUES (6, 14);
INSERT INTO B (s, t) VALUES (6, 16);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (10, 16);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO B (s, t) VALUES (11, 16);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO B (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO A (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (13, 7);
INSERT INTO B (s, t) VALUES (13, 9);
INSERT INTO A (s, t) VALUES (13, 14);
INSERT INTO B (s, t) VALUES (14, 3);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO A (s, t) VALUES (14, 6);
INSERT INTO A (s, t) VALUES (14, 9);
INSERT INTO A (s, t) VALUES (14, 10);
INSERT INTO A (s, t) VALUES (14, 11);
INSERT INTO A (s, t) VALUES (15, 1);
INSERT INTO A (s, t) VALUES (15, 8);
INSERT INTO B (s, t) VALUES (16, 2);
INSERT INTO A (s, t) VALUES (16, 3);
INSERT INTO A (s, t) VALUES (16, 5);
INSERT INTO A (s, t) VALUES (16, 9);
INSERT INTO A (s, t) VALUES (16, 14);
INSERT INTO B (s, t) VALUES (16, 15);
INSERT INTO StartLabel VALUES (16)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
17,0.2,19,true,12:44:14
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (0, 15);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 14);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 15);
INSERT INTO A (s, t) VALUES (3, 16);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (4, 14);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (5, 16);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (7, 15);
INSERT INTO A (s, t) VALUES (7, 16);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (8, 11);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO A (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (9, 14);
INSERT INTO B (s, t) VALUES (9, 16);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 13);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 4);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO B (s, t) VALUES (13, 1);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO B (s, t) VALUES (13, 16);
INSERT INTO A (s, t) VALUES (14, 3);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 7);
INSERT INTO B (s, t) VALUES (14, 8);
INSERT INTO B (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 1);
INSERT INTO B (s, t) VALUES (15, 6);
INSERT INTO A (s, t) VALUES (15, 8);
INSERT INTO B (s, t) VALUES (15, 14);
INSERT INTO B (s, t) VALUES (15, 15);
INSERT INTO B (s, t) VALUES (16, 0);
INSERT INTO A (s, t) VALUES (16, 3);
INSERT INTO B (s, t) VALUES (16, 8);
INSERT INTO B (s, t) VALUES (16, 12);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
17,0.2,19,true,12:44:14
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (0, 15);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 14);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 15);
INSERT INTO A (s, t) VALUES (3, 16);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (4, 14);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (5, 16);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (7, 15);
INSERT INTO A (s, t) VALUES (7, 16);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (8, 11);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO A (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (9, 14);
INSERT INTO B (s, t) VALUES (9, 16);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 13);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 4);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO B (s, t) VALUES (13, 1);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO B (s, t) VALUES (13, 16);
INSERT INTO A (s, t) VALUES (14, 3);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 7);
INSERT INTO B (s, t) VALUES (14, 8);
INSERT INTO B (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 1);
INSERT INTO B (s, t) VALUES (15, 6);
INSERT INTO A (s, t) VALUES (15, 8);
INSERT INTO B (s, t) VALUES (15, 14);
INSERT INTO B (s, t) VALUES (15, 15);
INSERT INTO B (s, t) VALUES (16, 0);
INSERT INTO A (s, t) VALUES (16, 3);
INSERT INTO B (s, t) VALUES (16, 8);
INSERT INTO B (s, t) VALUES (16, 12);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
17,0.2,19,true,12:44:15
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (0, 15);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 14);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 15);
INSERT INTO A (s, t) VALUES (3, 16);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (4, 14);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (5, 16);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (7, 15);
INSERT INTO A (s, t) VALUES (7, 16);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (8, 11);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO A (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (9, 14);
INSERT INTO B (s, t) VALUES (9, 16);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 13);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 4);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO B (s, t) VALUES (13, 1);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO B (s, t) VALUES (13, 16);
INSERT INTO A (s, t) VALUES (14, 3);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 7);
INSERT INTO B (s, t) VALUES (14, 8);
INSERT INTO B (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 1);
INSERT INTO B (s, t) VALUES (15, 6);
INSERT INTO A (s, t) VALUES (15, 8);
INSERT INTO B (s, t) VALUES (15, 14);
INSERT INTO B (s, t) VALUES (15, 15);
INSERT INTO B (s, t) VALUES (16, 0);
INSERT INTO A (s, t) VALUES (16, 3);
INSERT INTO B (s, t) VALUES (16, 8);
INSERT INTO B (s, t) VALUES (16, 12);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
17,0.2,19,true,12:44:15
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (0, 15);
INSERT INTO B (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 14);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 15);
INSERT INTO A (s, t) VALUES (3, 16);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (4, 14);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (5, 16);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO B (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (7, 15);
INSERT INTO A (s, t) VALUES (7, 16);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 10);
INSERT INTO B (s, t) VALUES (8, 11);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO A (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (9, 14);
INSERT INTO B (s, t) VALUES (9, 16);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO B (s, t) VALUES (10, 12);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 13);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 4);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO B (s, t) VALUES (13, 1);
INSERT INTO A (s, t) VALUES (13, 4);
INSERT INTO B (s, t) VALUES (13, 16);
INSERT INTO A (s, t) VALUES (14, 3);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 7);
INSERT INTO B (s, t) VALUES (14, 8);
INSERT INTO B (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 1);
INSERT INTO B (s, t) VALUES (15, 6);
INSERT INTO A (s, t) VALUES (15, 8);
INSERT INTO B (s, t) VALUES (15, 14);
INSERT INTO B (s, t) VALUES (15, 15);
INSERT INTO B (s, t) VALUES (16, 0);
INSERT INTO A (s, t) VALUES (16, 3);
INSERT INTO B (s, t) VALUES (16, 8);
INSERT INTO B (s, t) VALUES (16, 12);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (10)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
17,0.2,7252,false,12:44:29
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 12);
INSERT INTO B (s, t) VALUES (1, 14);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (2, 11);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 12);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (7, 15);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 14);
INSERT INTO A (s, t) VALUES (9, 15);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (10, 12);
INSERT INTO A (s, t) VALUES (10, 14);
INSERT INTO A (s, t) VALUES (10, 16);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO B (s, t) VALUES (12, 11);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO A (s, t) VALUES (13, 12);
INSERT INTO B (s, t) VALUES (14, 1);
INSERT INTO B (s, t) VALUES (14, 7);
INSERT INTO A (s, t) VALUES (14, 9);
INSERT INTO B (s, t) VALUES (14, 14);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO B (s, t) VALUES (15, 3);
INSERT INTO B (s, t) VALUES (15, 5);
INSERT INTO A (s, t) VALUES (15, 15);
INSERT INTO A (s, t) VALUES (15, 16);
INSERT INTO A (s, t) VALUES (16, 8);
INSERT INTO B (s, t) VALUES (16, 12);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
17,0.2,7252,false,12:44:36
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 12);
INSERT INTO B (s, t) VALUES (1, 14);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (2, 11);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 12);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (7, 15);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 14);
INSERT INTO A (s, t) VALUES (9, 15);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (10, 12);
INSERT INTO A (s, t) VALUES (10, 14);
INSERT INTO A (s, t) VALUES (10, 16);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO B (s, t) VALUES (12, 11);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO A (s, t) VALUES (13, 12);
INSERT INTO B (s, t) VALUES (14, 1);
INSERT INTO B (s, t) VALUES (14, 7);
INSERT INTO A (s, t) VALUES (14, 9);
INSERT INTO B (s, t) VALUES (14, 14);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO B (s, t) VALUES (15, 3);
INSERT INTO B (s, t) VALUES (15, 5);
INSERT INTO A (s, t) VALUES (15, 15);
INSERT INTO A (s, t) VALUES (15, 16);
INSERT INTO A (s, t) VALUES (16, 8);
INSERT INTO B (s, t) VALUES (16, 12);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
17,0.2,7244,false,12:44:44
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 12);
INSERT INTO B (s, t) VALUES (1, 14);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (2, 11);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 12);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (7, 15);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 14);
INSERT INTO A (s, t) VALUES (9, 15);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (10, 12);
INSERT INTO A (s, t) VALUES (10, 14);
INSERT INTO A (s, t) VALUES (10, 16);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO B (s, t) VALUES (12, 11);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO A (s, t) VALUES (13, 12);
INSERT INTO B (s, t) VALUES (14, 1);
INSERT INTO B (s, t) VALUES (14, 7);
INSERT INTO A (s, t) VALUES (14, 9);
INSERT INTO B (s, t) VALUES (14, 14);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO B (s, t) VALUES (15, 3);
INSERT INTO B (s, t) VALUES (15, 5);
INSERT INTO A (s, t) VALUES (15, 15);
INSERT INTO A (s, t) VALUES (15, 16);
INSERT INTO A (s, t) VALUES (16, 8);
INSERT INTO B (s, t) VALUES (16, 12);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
17,0.2,7246,false,12:44:51
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 12);
INSERT INTO B (s, t) VALUES (1, 14);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO B (s, t) VALUES (2, 11);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO A (s, t) VALUES (4, 6);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 12);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (7, 15);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 14);
INSERT INTO A (s, t) VALUES (9, 15);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (10, 12);
INSERT INTO A (s, t) VALUES (10, 14);
INSERT INTO A (s, t) VALUES (10, 16);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO B (s, t) VALUES (12, 11);
INSERT INTO A (s, t) VALUES (12, 12);
INSERT INTO A (s, t) VALUES (13, 12);
INSERT INTO B (s, t) VALUES (14, 1);
INSERT INTO B (s, t) VALUES (14, 7);
INSERT INTO A (s, t) VALUES (14, 9);
INSERT INTO B (s, t) VALUES (14, 14);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO B (s, t) VALUES (15, 3);
INSERT INTO B (s, t) VALUES (15, 5);
INSERT INTO A (s, t) VALUES (15, 15);
INSERT INTO A (s, t) VALUES (15, 16);
INSERT INTO A (s, t) VALUES (16, 8);
INSERT INTO B (s, t) VALUES (16, 12);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
17,0.2,97517,false,12:48:06
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 14);
INSERT INTO B (s, t) VALUES (0, 16);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (1, 12);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (2, 11);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO B (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (2, 14);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (4, 15);
INSERT INTO B (s, t) VALUES (4, 16);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 16);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 14);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 12);
INSERT INTO A (s, t) VALUES (9, 13);
INSERT INTO B (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (10, 16);
INSERT INTO A (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 14);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 8);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (14, 12);
INSERT INTO A (s, t) VALUES (15, 6);
INSERT INTO B (s, t) VALUES (15, 13);
INSERT INTO A (s, t) VALUES (15, 16);
INSERT INTO B (s, t) VALUES (16, 1);
INSERT INTO B (s, t) VALUES (16, 2);
INSERT INTO A (s, t) VALUES (16, 8);
INSERT INTO A (s, t) VALUES (16, 12);
INSERT INTO A (s, t) VALUES (16, 13);
INSERT INTO StartLabel VALUES (14)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
17,0.2,97532,false,12:49:43
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 14);
INSERT INTO B (s, t) VALUES (0, 16);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (1, 12);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (2, 11);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO B (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (2, 14);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (4, 15);
INSERT INTO B (s, t) VALUES (4, 16);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 16);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 14);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 12);
INSERT INTO A (s, t) VALUES (9, 13);
INSERT INTO B (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (10, 16);
INSERT INTO A (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 14);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 8);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (14, 12);
INSERT INTO A (s, t) VALUES (15, 6);
INSERT INTO B (s, t) VALUES (15, 13);
INSERT INTO A (s, t) VALUES (15, 16);
INSERT INTO B (s, t) VALUES (16, 1);
INSERT INTO B (s, t) VALUES (16, 2);
INSERT INTO A (s, t) VALUES (16, 8);
INSERT INTO A (s, t) VALUES (16, 12);
INSERT INTO A (s, t) VALUES (16, 13);
INSERT INTO StartLabel VALUES (14)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
17,0.2,97518,false,12:51:21
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 14);
INSERT INTO B (s, t) VALUES (0, 16);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (1, 12);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (2, 11);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO B (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (2, 14);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (4, 15);
INSERT INTO B (s, t) VALUES (4, 16);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 16);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 14);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 12);
INSERT INTO A (s, t) VALUES (9, 13);
INSERT INTO B (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (10, 16);
INSERT INTO A (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 14);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 8);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (14, 12);
INSERT INTO A (s, t) VALUES (15, 6);
INSERT INTO B (s, t) VALUES (15, 13);
INSERT INTO A (s, t) VALUES (15, 16);
INSERT INTO B (s, t) VALUES (16, 1);
INSERT INTO B (s, t) VALUES (16, 2);
INSERT INTO A (s, t) VALUES (16, 8);
INSERT INTO A (s, t) VALUES (16, 12);
INSERT INTO A (s, t) VALUES (16, 13);
INSERT INTO StartLabel VALUES (14)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
17,0.2,97558,false,12:52:59
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 14);
INSERT INTO B (s, t) VALUES (0, 16);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO B (s, t) VALUES (1, 12);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (2, 11);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO B (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (2, 14);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (4, 15);
INSERT INTO B (s, t) VALUES (4, 16);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 16);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 14);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO B (s, t) VALUES (9, 6);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 12);
INSERT INTO A (s, t) VALUES (9, 13);
INSERT INTO B (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 8);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (10, 16);
INSERT INTO A (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 14);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 8);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (14, 12);
INSERT INTO A (s, t) VALUES (15, 6);
INSERT INTO B (s, t) VALUES (15, 13);
INSERT INTO A (s, t) VALUES (15, 16);
INSERT INTO B (s, t) VALUES (16, 1);
INSERT INTO B (s, t) VALUES (16, 2);
INSERT INTO A (s, t) VALUES (16, 8);
INSERT INTO A (s, t) VALUES (16, 12);
INSERT INTO A (s, t) VALUES (16, 13);
INSERT INTO StartLabel VALUES (14)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
18,0.2,34,false,12:52:59
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 11);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (2, 16);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 17);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (4, 16);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 11);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (6, 15);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 15);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 13);
INSERT INTO A (s, t) VALUES (8, 15);
INSERT INTO B (s, t) VALUES (9, 13);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO B (s, t) VALUES (10, 3);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (10, 15);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 10);
INSERT INTO A (s, t) VALUES (11, 13);
INSERT INTO A (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO A (s, t) VALUES (13, 9);
INSERT INTO A (s, t) VALUES (14, 2);
INSERT INTO A (s, t) VALUES (14, 3);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 6);
INSERT INTO B (s, t) VALUES (14, 12);
INSERT INTO B (s, t) VALUES (14, 17);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 4);
INSERT INTO B (s, t) VALUES (15, 6);
INSERT INTO B (s, t) VALUES (16, 2);
INSERT INTO B (s, t) VALUES (16, 4);
INSERT INTO A (s, t) VALUES (16, 7);
INSERT INTO A (s, t) VALUES (16, 10);
INSERT INTO A (s, t) VALUES (16, 17);
INSERT INTO StartLabel VALUES (17)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
18,0.2,34,false,12:52:59
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 11);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (2, 16);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 17);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (4, 16);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 11);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (6, 15);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 15);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 13);
INSERT INTO A (s, t) VALUES (8, 15);
INSERT INTO B (s, t) VALUES (9, 13);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO B (s, t) VALUES (10, 3);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (10, 15);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 10);
INSERT INTO A (s, t) VALUES (11, 13);
INSERT INTO A (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO A (s, t) VALUES (13, 9);
INSERT INTO A (s, t) VALUES (14, 2);
INSERT INTO A (s, t) VALUES (14, 3);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 6);
INSERT INTO B (s, t) VALUES (14, 12);
INSERT INTO B (s, t) VALUES (14, 17);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 4);
INSERT INTO B (s, t) VALUES (15, 6);
INSERT INTO B (s, t) VALUES (16, 2);
INSERT INTO B (s, t) VALUES (16, 4);
INSERT INTO A (s, t) VALUES (16, 7);
INSERT INTO A (s, t) VALUES (16, 10);
INSERT INTO A (s, t) VALUES (16, 17);
INSERT INTO StartLabel VALUES (17)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
18,0.2,34,false,12:52:59
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 11);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (2, 16);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 17);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (4, 16);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 11);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (6, 15);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 15);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 13);
INSERT INTO A (s, t) VALUES (8, 15);
INSERT INTO B (s, t) VALUES (9, 13);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO B (s, t) VALUES (10, 3);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (10, 15);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 10);
INSERT INTO A (s, t) VALUES (11, 13);
INSERT INTO A (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO A (s, t) VALUES (13, 9);
INSERT INTO A (s, t) VALUES (14, 2);
INSERT INTO A (s, t) VALUES (14, 3);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 6);
INSERT INTO B (s, t) VALUES (14, 12);
INSERT INTO B (s, t) VALUES (14, 17);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 4);
INSERT INTO B (s, t) VALUES (15, 6);
INSERT INTO B (s, t) VALUES (16, 2);
INSERT INTO B (s, t) VALUES (16, 4);
INSERT INTO A (s, t) VALUES (16, 7);
INSERT INTO A (s, t) VALUES (16, 10);
INSERT INTO A (s, t) VALUES (16, 17);
INSERT INTO StartLabel VALUES (17)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
18,0.2,34,false,12:52:59
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 4);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 8);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 11);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (2, 16);
INSERT INTO A (s, t) VALUES (3, 0);
INSERT INTO B (s, t) VALUES (3, 4);
INSERT INTO A (s, t) VALUES (3, 17);
INSERT INTO B (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (4, 16);
INSERT INTO B (s, t) VALUES (5, 3);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 11);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (6, 15);
INSERT INTO B (s, t) VALUES (7, 2);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 15);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 13);
INSERT INTO A (s, t) VALUES (8, 15);
INSERT INTO B (s, t) VALUES (9, 13);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO B (s, t) VALUES (10, 3);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (10, 15);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 10);
INSERT INTO A (s, t) VALUES (11, 13);
INSERT INTO A (s, t) VALUES (12, 5);
INSERT INTO A (s, t) VALUES (12, 10);
INSERT INTO A (s, t) VALUES (13, 9);
INSERT INTO A (s, t) VALUES (14, 2);
INSERT INTO A (s, t) VALUES (14, 3);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 6);
INSERT INTO B (s, t) VALUES (14, 12);
INSERT INTO B (s, t) VALUES (14, 17);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 4);
INSERT INTO B (s, t) VALUES (15, 6);
INSERT INTO B (s, t) VALUES (16, 2);
INSERT INTO B (s, t) VALUES (16, 4);
INSERT INTO A (s, t) VALUES (16, 7);
INSERT INTO A (s, t) VALUES (16, 10);
INSERT INTO A (s, t) VALUES (16, 17);
INSERT INTO StartLabel VALUES (17)
INSERT INTO EndLabel VALUES (2)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
18,0.2,7453,false,12:53:14
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 14);
INSERT INTO A (s, t) VALUES (0, 17);
INSERT INTO B (s, t) VALUES (1, 15);
INSERT INTO A (s, t) VALUES (1, 16);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (2, 11);
INSERT INTO B (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 14);
INSERT INTO A (s, t) VALUES (3, 16);
INSERT INTO B (s, t) VALUES (4, 12);
INSERT INTO A (s, t) VALUES (4, 16);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 14);
INSERT INTO B (s, t) VALUES (5, 15);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 15);
INSERT INTO B (s, t) VALUES (8, 13);
INSERT INTO B (s, t) VALUES (8, 14);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO B (s, t) VALUES (10, 14);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 17);
INSERT INTO B (s, t) VALUES (12, 12);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (12, 15);
INSERT INTO A (s, t) VALUES (13, 15);
INSERT INTO B (s, t) VALUES (14, 13);
INSERT INTO B (s, t) VALUES (14, 14);
INSERT INTO B (s, t) VALUES (14, 17);
INSERT INTO A (s, t) VALUES (15, 2);
INSERT INTO A (s, t) VALUES (16, 9);
INSERT INTO B (s, t) VALUES (16, 10);
INSERT INTO B (s, t) VALUES (17, 1);
INSERT INTO A (s, t) VALUES (17, 10);
INSERT INTO B (s, t) VALUES (17, 12);
INSERT INTO StartLabel VALUES (17)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
18,0.2,7467,false,12:53:21
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 14);
INSERT INTO A (s, t) VALUES (0, 17);
INSERT INTO B (s, t) VALUES (1, 15);
INSERT INTO A (s, t) VALUES (1, 16);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (2, 11);
INSERT INTO B (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 14);
INSERT INTO A (s, t) VALUES (3, 16);
INSERT INTO B (s, t) VALUES (4, 12);
INSERT INTO A (s, t) VALUES (4, 16);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 14);
INSERT INTO B (s, t) VALUES (5, 15);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 15);
INSERT INTO B (s, t) VALUES (8, 13);
INSERT INTO B (s, t) VALUES (8, 14);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO B (s, t) VALUES (10, 14);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 17);
INSERT INTO B (s, t) VALUES (12, 12);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (12, 15);
INSERT INTO A (s, t) VALUES (13, 15);
INSERT INTO B (s, t) VALUES (14, 13);
INSERT INTO B (s, t) VALUES (14, 14);
INSERT INTO B (s, t) VALUES (14, 17);
INSERT INTO A (s, t) VALUES (15, 2);
INSERT INTO A (s, t) VALUES (16, 9);
INSERT INTO B (s, t) VALUES (16, 10);
INSERT INTO B (s, t) VALUES (17, 1);
INSERT INTO A (s, t) VALUES (17, 10);
INSERT INTO B (s, t) VALUES (17, 12);
INSERT INTO StartLabel VALUES (17)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
18,0.2,7440,false,12:53:29
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 14);
INSERT INTO A (s, t) VALUES (0, 17);
INSERT INTO B (s, t) VALUES (1, 15);
INSERT INTO A (s, t) VALUES (1, 16);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (2, 11);
INSERT INTO B (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 14);
INSERT INTO A (s, t) VALUES (3, 16);
INSERT INTO B (s, t) VALUES (4, 12);
INSERT INTO A (s, t) VALUES (4, 16);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 14);
INSERT INTO B (s, t) VALUES (5, 15);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 15);
INSERT INTO B (s, t) VALUES (8, 13);
INSERT INTO B (s, t) VALUES (8, 14);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO B (s, t) VALUES (10, 14);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 17);
INSERT INTO B (s, t) VALUES (12, 12);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (12, 15);
INSERT INTO A (s, t) VALUES (13, 15);
INSERT INTO B (s, t) VALUES (14, 13);
INSERT INTO B (s, t) VALUES (14, 14);
INSERT INTO B (s, t) VALUES (14, 17);
INSERT INTO A (s, t) VALUES (15, 2);
INSERT INTO A (s, t) VALUES (16, 9);
INSERT INTO B (s, t) VALUES (16, 10);
INSERT INTO B (s, t) VALUES (17, 1);
INSERT INTO A (s, t) VALUES (17, 10);
INSERT INTO B (s, t) VALUES (17, 12);
INSERT INTO StartLabel VALUES (17)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
18,0.2,7436,false,12:53:36
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 7);
INSERT INTO B (s, t) VALUES (0, 14);
INSERT INTO A (s, t) VALUES (0, 17);
INSERT INTO B (s, t) VALUES (1, 15);
INSERT INTO A (s, t) VALUES (1, 16);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (2, 11);
INSERT INTO B (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 14);
INSERT INTO A (s, t) VALUES (3, 16);
INSERT INTO B (s, t) VALUES (4, 12);
INSERT INTO A (s, t) VALUES (4, 16);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 14);
INSERT INTO B (s, t) VALUES (5, 15);
INSERT INTO A (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 15);
INSERT INTO B (s, t) VALUES (8, 13);
INSERT INTO B (s, t) VALUES (8, 14);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 2);
INSERT INTO B (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 12);
INSERT INTO B (s, t) VALUES (10, 1);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO B (s, t) VALUES (10, 14);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 17);
INSERT INTO B (s, t) VALUES (12, 12);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO A (s, t) VALUES (12, 15);
INSERT INTO A (s, t) VALUES (13, 15);
INSERT INTO B (s, t) VALUES (14, 13);
INSERT INTO B (s, t) VALUES (14, 14);
INSERT INTO B (s, t) VALUES (14, 17);
INSERT INTO A (s, t) VALUES (15, 2);
INSERT INTO A (s, t) VALUES (16, 9);
INSERT INTO B (s, t) VALUES (16, 10);
INSERT INTO B (s, t) VALUES (17, 1);
INSERT INTO A (s, t) VALUES (17, 10);
INSERT INTO B (s, t) VALUES (17, 12);
INSERT INTO StartLabel VALUES (17)
INSERT INTO EndLabel VALUES (9)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
18,0.2,977,true,12:53:38
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (1, 13);
INSERT INTO A (s, t) VALUES (1, 17);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (2, 11);
INSERT INTO A (s, t) VALUES (2, 16);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (4, 14);
INSERT INTO B (s, t) VALUES (4, 15);
INSERT INTO A (s, t) VALUES (4, 17);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 14);
INSERT INTO B (s, t) VALUES (5, 15);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (6, 16);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (7, 12);
INSERT INTO A (s, t) VALUES (7, 16);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (9, 13);
INSERT INTO B (s, t) VALUES (9, 15);
INSERT INTO B (s, t) VALUES (9, 16);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 11);
INSERT INTO A (s, t) VALUES (12, 14);
INSERT INTO B (s, t) VALUES (12, 15);
INSERT INTO A (s, t) VALUES (12, 16);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 12);
INSERT INTO B (s, t) VALUES (14, 14);
INSERT INTO A (s, t) VALUES (15, 1);
INSERT INTO B (s, t) VALUES (15, 5);
INSERT INTO B (s, t) VALUES (15, 11);
INSERT INTO A (s, t) VALUES (15, 16);
INSERT INTO A (s, t) VALUES (16, 2);
INSERT INTO B (s, t) VALUES (16, 5);
INSERT INTO B (s, t) VALUES (16, 16);
INSERT INTO A (s, t) VALUES (17, 0);
INSERT INTO B (s, t) VALUES (17, 4);
INSERT INTO A (s, t) VALUES (17, 10);
INSERT INTO B (s, t) VALUES (17, 13);
INSERT INTO A (s, t) VALUES (17, 15);
INSERT INTO A (s, t) VALUES (17, 17);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
18,0.2,977,true,12:53:39
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (1, 13);
INSERT INTO A (s, t) VALUES (1, 17);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (2, 11);
INSERT INTO A (s, t) VALUES (2, 16);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (4, 14);
INSERT INTO B (s, t) VALUES (4, 15);
INSERT INTO A (s, t) VALUES (4, 17);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 14);
INSERT INTO B (s, t) VALUES (5, 15);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (6, 16);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (7, 12);
INSERT INTO A (s, t) VALUES (7, 16);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (9, 13);
INSERT INTO B (s, t) VALUES (9, 15);
INSERT INTO B (s, t) VALUES (9, 16);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 11);
INSERT INTO A (s, t) VALUES (12, 14);
INSERT INTO B (s, t) VALUES (12, 15);
INSERT INTO A (s, t) VALUES (12, 16);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 12);
INSERT INTO B (s, t) VALUES (14, 14);
INSERT INTO A (s, t) VALUES (15, 1);
INSERT INTO B (s, t) VALUES (15, 5);
INSERT INTO B (s, t) VALUES (15, 11);
INSERT INTO A (s, t) VALUES (15, 16);
INSERT INTO A (s, t) VALUES (16, 2);
INSERT INTO B (s, t) VALUES (16, 5);
INSERT INTO B (s, t) VALUES (16, 16);
INSERT INTO A (s, t) VALUES (17, 0);
INSERT INTO B (s, t) VALUES (17, 4);
INSERT INTO A (s, t) VALUES (17, 10);
INSERT INTO B (s, t) VALUES (17, 13);
INSERT INTO A (s, t) VALUES (17, 15);
INSERT INTO A (s, t) VALUES (17, 17);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
18,0.2,976,true,12:53:40
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (1, 13);
INSERT INTO A (s, t) VALUES (1, 17);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (2, 11);
INSERT INTO A (s, t) VALUES (2, 16);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (4, 14);
INSERT INTO B (s, t) VALUES (4, 15);
INSERT INTO A (s, t) VALUES (4, 17);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 14);
INSERT INTO B (s, t) VALUES (5, 15);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (6, 16);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (7, 12);
INSERT INTO A (s, t) VALUES (7, 16);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (9, 13);
INSERT INTO B (s, t) VALUES (9, 15);
INSERT INTO B (s, t) VALUES (9, 16);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 11);
INSERT INTO A (s, t) VALUES (12, 14);
INSERT INTO B (s, t) VALUES (12, 15);
INSERT INTO A (s, t) VALUES (12, 16);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 12);
INSERT INTO B (s, t) VALUES (14, 14);
INSERT INTO A (s, t) VALUES (15, 1);
INSERT INTO B (s, t) VALUES (15, 5);
INSERT INTO B (s, t) VALUES (15, 11);
INSERT INTO A (s, t) VALUES (15, 16);
INSERT INTO A (s, t) VALUES (16, 2);
INSERT INTO B (s, t) VALUES (16, 5);
INSERT INTO B (s, t) VALUES (16, 16);
INSERT INTO A (s, t) VALUES (17, 0);
INSERT INTO B (s, t) VALUES (17, 4);
INSERT INTO A (s, t) VALUES (17, 10);
INSERT INTO B (s, t) VALUES (17, 13);
INSERT INTO A (s, t) VALUES (17, 15);
INSERT INTO A (s, t) VALUES (17, 17);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
18,0.2,980,true,12:53:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO A (s, t) VALUES (1, 8);
INSERT INTO A (s, t) VALUES (1, 9);
INSERT INTO A (s, t) VALUES (1, 13);
INSERT INTO A (s, t) VALUES (1, 17);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO B (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (2, 11);
INSERT INTO A (s, t) VALUES (2, 16);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 2);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (4, 14);
INSERT INTO B (s, t) VALUES (4, 15);
INSERT INTO A (s, t) VALUES (4, 17);
INSERT INTO A (s, t) VALUES (5, 3);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 14);
INSERT INTO B (s, t) VALUES (5, 15);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (6, 16);
INSERT INTO B (s, t) VALUES (7, 9);
INSERT INTO A (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (7, 12);
INSERT INTO A (s, t) VALUES (7, 16);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (9, 13);
INSERT INTO B (s, t) VALUES (9, 15);
INSERT INTO B (s, t) VALUES (9, 16);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO A (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 4);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 11);
INSERT INTO A (s, t) VALUES (12, 14);
INSERT INTO B (s, t) VALUES (12, 15);
INSERT INTO A (s, t) VALUES (12, 16);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 12);
INSERT INTO B (s, t) VALUES (14, 14);
INSERT INTO A (s, t) VALUES (15, 1);
INSERT INTO B (s, t) VALUES (15, 5);
INSERT INTO B (s, t) VALUES (15, 11);
INSERT INTO A (s, t) VALUES (15, 16);
INSERT INTO A (s, t) VALUES (16, 2);
INSERT INTO B (s, t) VALUES (16, 5);
INSERT INTO B (s, t) VALUES (16, 16);
INSERT INTO A (s, t) VALUES (17, 0);
INSERT INTO B (s, t) VALUES (17, 4);
INSERT INTO A (s, t) VALUES (17, 10);
INSERT INTO B (s, t) VALUES (17, 13);
INSERT INTO A (s, t) VALUES (17, 15);
INSERT INTO A (s, t) VALUES (17, 17);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (8)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
18,0.2,28,true,12:53:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (0, 17);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 14);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (2, 12);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 12);
INSERT INTO A (s, t) VALUES (4, 14);
INSERT INTO A (s, t) VALUES (4, 16);
INSERT INTO A (s, t) VALUES (5, 13);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 12);
INSERT INTO B (s, t) VALUES (6, 16);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 16);
INSERT INTO A (s, t) VALUES (7, 17);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 17);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 13);
INSERT INTO A (s, t) VALUES (9, 14);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 7);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 11);
INSERT INTO B (s, t) VALUES (11, 16);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO B (s, t) VALUES (13, 11);
INSERT INTO B (s, t) VALUES (13, 12);
INSERT INTO B (s, t) VALUES (13, 15);
INSERT INTO A (s, t) VALUES (14, 12);
INSERT INTO A (s, t) VALUES (15, 1);
INSERT INTO B (s, t) VALUES (15, 14);
INSERT INTO B (s, t) VALUES (15, 16);
INSERT INTO B (s, t) VALUES (16, 0);
INSERT INTO B (s, t) VALUES (16, 2);
INSERT INTO A (s, t) VALUES (16, 3);
INSERT INTO A (s, t) VALUES (16, 4);
INSERT INTO A (s, t) VALUES (16, 9);
INSERT INTO B (s, t) VALUES (17, 9);
INSERT INTO A (s, t) VALUES (17, 10);
INSERT INTO B (s, t) VALUES (17, 11);
INSERT INTO A (s, t) VALUES (17, 14);
INSERT INTO B (s, t) VALUES (17, 15);
INSERT INTO A (s, t) VALUES (17, 16);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (13)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
18,0.2,28,true,12:53:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (0, 17);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 14);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (2, 12);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 12);
INSERT INTO A (s, t) VALUES (4, 14);
INSERT INTO A (s, t) VALUES (4, 16);
INSERT INTO A (s, t) VALUES (5, 13);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 12);
INSERT INTO B (s, t) VALUES (6, 16);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 16);
INSERT INTO A (s, t) VALUES (7, 17);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 17);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 13);
INSERT INTO A (s, t) VALUES (9, 14);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 7);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 11);
INSERT INTO B (s, t) VALUES (11, 16);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO B (s, t) VALUES (13, 11);
INSERT INTO B (s, t) VALUES (13, 12);
INSERT INTO B (s, t) VALUES (13, 15);
INSERT INTO A (s, t) VALUES (14, 12);
INSERT INTO A (s, t) VALUES (15, 1);
INSERT INTO B (s, t) VALUES (15, 14);
INSERT INTO B (s, t) VALUES (15, 16);
INSERT INTO B (s, t) VALUES (16, 0);
INSERT INTO B (s, t) VALUES (16, 2);
INSERT INTO A (s, t) VALUES (16, 3);
INSERT INTO A (s, t) VALUES (16, 4);
INSERT INTO A (s, t) VALUES (16, 9);
INSERT INTO B (s, t) VALUES (17, 9);
INSERT INTO A (s, t) VALUES (17, 10);
INSERT INTO B (s, t) VALUES (17, 11);
INSERT INTO A (s, t) VALUES (17, 14);
INSERT INTO B (s, t) VALUES (17, 15);
INSERT INTO A (s, t) VALUES (17, 16);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (13)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
18,0.2,28,true,12:53:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (0, 17);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 14);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (2, 12);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 12);
INSERT INTO A (s, t) VALUES (4, 14);
INSERT INTO A (s, t) VALUES (4, 16);
INSERT INTO A (s, t) VALUES (5, 13);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 12);
INSERT INTO B (s, t) VALUES (6, 16);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 16);
INSERT INTO A (s, t) VALUES (7, 17);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 17);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 13);
INSERT INTO A (s, t) VALUES (9, 14);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 7);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 11);
INSERT INTO B (s, t) VALUES (11, 16);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO B (s, t) VALUES (13, 11);
INSERT INTO B (s, t) VALUES (13, 12);
INSERT INTO B (s, t) VALUES (13, 15);
INSERT INTO A (s, t) VALUES (14, 12);
INSERT INTO A (s, t) VALUES (15, 1);
INSERT INTO B (s, t) VALUES (15, 14);
INSERT INTO B (s, t) VALUES (15, 16);
INSERT INTO B (s, t) VALUES (16, 0);
INSERT INTO B (s, t) VALUES (16, 2);
INSERT INTO A (s, t) VALUES (16, 3);
INSERT INTO A (s, t) VALUES (16, 4);
INSERT INTO A (s, t) VALUES (16, 9);
INSERT INTO B (s, t) VALUES (17, 9);
INSERT INTO A (s, t) VALUES (17, 10);
INSERT INTO B (s, t) VALUES (17, 11);
INSERT INTO A (s, t) VALUES (17, 14);
INSERT INTO B (s, t) VALUES (17, 15);
INSERT INTO A (s, t) VALUES (17, 16);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (13)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
18,0.2,28,true,12:53:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 4);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO B (s, t) VALUES (0, 17);
INSERT INTO A (s, t) VALUES (1, 0);
INSERT INTO A (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 3);
INSERT INTO A (s, t) VALUES (1, 14);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (2, 12);
INSERT INTO B (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 4);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO B (s, t) VALUES (4, 7);
INSERT INTO A (s, t) VALUES (4, 12);
INSERT INTO A (s, t) VALUES (4, 14);
INSERT INTO A (s, t) VALUES (4, 16);
INSERT INTO A (s, t) VALUES (5, 13);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 12);
INSERT INTO B (s, t) VALUES (6, 16);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 16);
INSERT INTO A (s, t) VALUES (7, 17);
INSERT INTO A (s, t) VALUES (8, 0);
INSERT INTO A (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (8, 17);
INSERT INTO B (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 13);
INSERT INTO A (s, t) VALUES (9, 14);
INSERT INTO B (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 7);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO A (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 11);
INSERT INTO B (s, t) VALUES (11, 16);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO B (s, t) VALUES (13, 11);
INSERT INTO B (s, t) VALUES (13, 12);
INSERT INTO B (s, t) VALUES (13, 15);
INSERT INTO A (s, t) VALUES (14, 12);
INSERT INTO A (s, t) VALUES (15, 1);
INSERT INTO B (s, t) VALUES (15, 14);
INSERT INTO B (s, t) VALUES (15, 16);
INSERT INTO B (s, t) VALUES (16, 0);
INSERT INTO B (s, t) VALUES (16, 2);
INSERT INTO A (s, t) VALUES (16, 3);
INSERT INTO A (s, t) VALUES (16, 4);
INSERT INTO A (s, t) VALUES (16, 9);
INSERT INTO B (s, t) VALUES (17, 9);
INSERT INTO A (s, t) VALUES (17, 10);
INSERT INTO B (s, t) VALUES (17, 11);
INSERT INTO A (s, t) VALUES (17, 14);
INSERT INTO B (s, t) VALUES (17, 15);
INSERT INTO A (s, t) VALUES (17, 16);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (13)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
18,0.2,timeout,false,13:03:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (0, 17);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 15);
INSERT INTO A (s, t) VALUES (1, 16);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (2, 14);
INSERT INTO B (s, t) VALUES (2, 17);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO B (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 15);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO A (s, t) VALUES (5, 14);
INSERT INTO B (s, t) VALUES (5, 15);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (6, 12);
INSERT INTO B (s, t) VALUES (7, 17);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO B (s, t) VALUES (8, 13);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 17);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO A (s, t) VALUES (12, 5);
INSERT INTO B (s, t) VALUES (12, 10);
INSERT INTO B (s, t) VALUES (12, 15);
INSERT INTO B (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 1);
INSERT INTO A (s, t) VALUES (13, 11);
INSERT INTO A (s, t) VALUES (13, 15);
INSERT INTO B (s, t) VALUES (14, 0);
INSERT INTO A (s, t) VALUES (14, 4);
INSERT INTO A (s, t) VALUES (14, 5);
INSERT INTO B (s, t) VALUES (14, 8);
INSERT INTO A (s, t) VALUES (14, 10);
INSERT INTO B (s, t) VALUES (14, 12);
INSERT INTO B (s, t) VALUES (15, 2);
INSERT INTO A (s, t) VALUES (15, 4);
INSERT INTO A (s, t) VALUES (15, 14);
INSERT INTO A (s, t) VALUES (16, 0);
INSERT INTO B (s, t) VALUES (16, 2);
INSERT INTO A (s, t) VALUES (16, 7);
INSERT INTO B (s, t) VALUES (16, 13);
INSERT INTO A (s, t) VALUES (16, 15);
INSERT INTO A (s, t) VALUES (17, 2);
INSERT INTO B (s, t) VALUES (17, 13);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
18,0.2,timeout,false,13:08:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (0, 17);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 15);
INSERT INTO A (s, t) VALUES (1, 16);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (2, 14);
INSERT INTO B (s, t) VALUES (2, 17);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO B (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 15);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO A (s, t) VALUES (5, 14);
INSERT INTO B (s, t) VALUES (5, 15);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (6, 12);
INSERT INTO B (s, t) VALUES (7, 17);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO B (s, t) VALUES (8, 13);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 17);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO A (s, t) VALUES (12, 5);
INSERT INTO B (s, t) VALUES (12, 10);
INSERT INTO B (s, t) VALUES (12, 15);
INSERT INTO B (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 1);
INSERT INTO A (s, t) VALUES (13, 11);
INSERT INTO A (s, t) VALUES (13, 15);
INSERT INTO B (s, t) VALUES (14, 0);
INSERT INTO A (s, t) VALUES (14, 4);
INSERT INTO A (s, t) VALUES (14, 5);
INSERT INTO B (s, t) VALUES (14, 8);
INSERT INTO A (s, t) VALUES (14, 10);
INSERT INTO B (s, t) VALUES (14, 12);
INSERT INTO B (s, t) VALUES (15, 2);
INSERT INTO A (s, t) VALUES (15, 4);
INSERT INTO A (s, t) VALUES (15, 14);
INSERT INTO A (s, t) VALUES (16, 0);
INSERT INTO B (s, t) VALUES (16, 2);
INSERT INTO A (s, t) VALUES (16, 7);
INSERT INTO B (s, t) VALUES (16, 13);
INSERT INTO A (s, t) VALUES (16, 15);
INSERT INTO A (s, t) VALUES (17, 2);
INSERT INTO B (s, t) VALUES (17, 13);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
18,0.2,timeout,false,13:13:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (0, 17);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 15);
INSERT INTO A (s, t) VALUES (1, 16);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (2, 14);
INSERT INTO B (s, t) VALUES (2, 17);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO B (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 15);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO A (s, t) VALUES (5, 14);
INSERT INTO B (s, t) VALUES (5, 15);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (6, 12);
INSERT INTO B (s, t) VALUES (7, 17);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO B (s, t) VALUES (8, 13);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 17);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO A (s, t) VALUES (12, 5);
INSERT INTO B (s, t) VALUES (12, 10);
INSERT INTO B (s, t) VALUES (12, 15);
INSERT INTO B (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 1);
INSERT INTO A (s, t) VALUES (13, 11);
INSERT INTO A (s, t) VALUES (13, 15);
INSERT INTO B (s, t) VALUES (14, 0);
INSERT INTO A (s, t) VALUES (14, 4);
INSERT INTO A (s, t) VALUES (14, 5);
INSERT INTO B (s, t) VALUES (14, 8);
INSERT INTO A (s, t) VALUES (14, 10);
INSERT INTO B (s, t) VALUES (14, 12);
INSERT INTO B (s, t) VALUES (15, 2);
INSERT INTO A (s, t) VALUES (15, 4);
INSERT INTO A (s, t) VALUES (15, 14);
INSERT INTO A (s, t) VALUES (16, 0);
INSERT INTO B (s, t) VALUES (16, 2);
INSERT INTO A (s, t) VALUES (16, 7);
INSERT INTO B (s, t) VALUES (16, 13);
INSERT INTO A (s, t) VALUES (16, 15);
INSERT INTO A (s, t) VALUES (17, 2);
INSERT INTO B (s, t) VALUES (17, 13);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
18,0.2,timeout,false,13:18:41
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 8);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (0, 17);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 15);
INSERT INTO A (s, t) VALUES (1, 16);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (2, 14);
INSERT INTO B (s, t) VALUES (2, 17);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO B (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 15);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO A (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 10);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO A (s, t) VALUES (5, 14);
INSERT INTO B (s, t) VALUES (5, 15);
INSERT INTO B (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (6, 12);
INSERT INTO B (s, t) VALUES (7, 17);
INSERT INTO B (s, t) VALUES (8, 4);
INSERT INTO A (s, t) VALUES (8, 11);
INSERT INTO B (s, t) VALUES (8, 13);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 17);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO B (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO A (s, t) VALUES (12, 5);
INSERT INTO B (s, t) VALUES (12, 10);
INSERT INTO B (s, t) VALUES (12, 15);
INSERT INTO B (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 1);
INSERT INTO A (s, t) VALUES (13, 11);
INSERT INTO A (s, t) VALUES (13, 15);
INSERT INTO B (s, t) VALUES (14, 0);
INSERT INTO A (s, t) VALUES (14, 4);
INSERT INTO A (s, t) VALUES (14, 5);
INSERT INTO B (s, t) VALUES (14, 8);
INSERT INTO A (s, t) VALUES (14, 10);
INSERT INTO B (s, t) VALUES (14, 12);
INSERT INTO B (s, t) VALUES (15, 2);
INSERT INTO A (s, t) VALUES (15, 4);
INSERT INTO A (s, t) VALUES (15, 14);
INSERT INTO A (s, t) VALUES (16, 0);
INSERT INTO B (s, t) VALUES (16, 2);
INSERT INTO A (s, t) VALUES (16, 7);
INSERT INTO B (s, t) VALUES (16, 13);
INSERT INTO A (s, t) VALUES (16, 15);
INSERT INTO A (s, t) VALUES (17, 2);
INSERT INTO B (s, t) VALUES (17, 13);
INSERT INTO StartLabel VALUES (11)
INSERT INTO EndLabel VALUES (3)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
19,0.2,67,true,13:18:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (0, 14);
INSERT INTO B (s, t) VALUES (0, 16);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (3, 14);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (4, 17);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO B (s, t) VALUES (5, 16);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (6, 15);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (7, 16);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO A (s, t) VALUES (9, 17);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO A (s, t) VALUES (10, 15);
INSERT INTO A (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 16);
INSERT INTO B (s, t) VALUES (11, 18);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO B (s, t) VALUES (12, 1);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO A (s, t) VALUES (12, 9);
INSERT INTO B (s, t) VALUES (13, 3);
INSERT INTO A (s, t) VALUES (13, 13);
INSERT INTO A (s, t) VALUES (14, 1);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 6);
INSERT INTO A (s, t) VALUES (14, 8);
INSERT INTO A (s, t) VALUES (14, 12);
INSERT INTO B (s, t) VALUES (15, 1);
INSERT INTO B (s, t) VALUES (15, 2);
INSERT INTO A (s, t) VALUES (15, 9);
INSERT INTO B (s, t) VALUES (15, 17);
INSERT INTO B (s, t) VALUES (16, 0);
INSERT INTO A (s, t) VALUES (16, 2);
INSERT INTO A (s, t) VALUES (16, 7);
INSERT INTO B (s, t) VALUES (16, 11);
INSERT INTO B (s, t) VALUES (16, 12);
INSERT INTO B (s, t) VALUES (16, 13);
INSERT INTO A (s, t) VALUES (16, 14);
INSERT INTO B (s, t) VALUES (16, 18);
INSERT INTO A (s, t) VALUES (17, 10);
INSERT INTO B (s, t) VALUES (17, 13);
INSERT INTO A (s, t) VALUES (17, 14);
INSERT INTO B (s, t) VALUES (17, 16);
INSERT INTO A (s, t) VALUES (17, 17);
INSERT INTO A (s, t) VALUES (18, 10);
INSERT INTO A (s, t) VALUES (18, 16);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
19,0.2,67,true,13:18:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (0, 14);
INSERT INTO B (s, t) VALUES (0, 16);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (3, 14);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (4, 17);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO B (s, t) VALUES (5, 16);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (6, 15);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (7, 16);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO A (s, t) VALUES (9, 17);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO A (s, t) VALUES (10, 15);
INSERT INTO A (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 16);
INSERT INTO B (s, t) VALUES (11, 18);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO B (s, t) VALUES (12, 1);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO A (s, t) VALUES (12, 9);
INSERT INTO B (s, t) VALUES (13, 3);
INSERT INTO A (s, t) VALUES (13, 13);
INSERT INTO A (s, t) VALUES (14, 1);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 6);
INSERT INTO A (s, t) VALUES (14, 8);
INSERT INTO A (s, t) VALUES (14, 12);
INSERT INTO B (s, t) VALUES (15, 1);
INSERT INTO B (s, t) VALUES (15, 2);
INSERT INTO A (s, t) VALUES (15, 9);
INSERT INTO B (s, t) VALUES (15, 17);
INSERT INTO B (s, t) VALUES (16, 0);
INSERT INTO A (s, t) VALUES (16, 2);
INSERT INTO A (s, t) VALUES (16, 7);
INSERT INTO B (s, t) VALUES (16, 11);
INSERT INTO B (s, t) VALUES (16, 12);
INSERT INTO B (s, t) VALUES (16, 13);
INSERT INTO A (s, t) VALUES (16, 14);
INSERT INTO B (s, t) VALUES (16, 18);
INSERT INTO A (s, t) VALUES (17, 10);
INSERT INTO B (s, t) VALUES (17, 13);
INSERT INTO A (s, t) VALUES (17, 14);
INSERT INTO B (s, t) VALUES (17, 16);
INSERT INTO A (s, t) VALUES (17, 17);
INSERT INTO A (s, t) VALUES (18, 10);
INSERT INTO A (s, t) VALUES (18, 16);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
19,0.2,67,true,13:18:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (0, 14);
INSERT INTO B (s, t) VALUES (0, 16);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (3, 14);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (4, 17);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO B (s, t) VALUES (5, 16);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (6, 15);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (7, 16);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO A (s, t) VALUES (9, 17);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO A (s, t) VALUES (10, 15);
INSERT INTO A (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 16);
INSERT INTO B (s, t) VALUES (11, 18);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO B (s, t) VALUES (12, 1);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO A (s, t) VALUES (12, 9);
INSERT INTO B (s, t) VALUES (13, 3);
INSERT INTO A (s, t) VALUES (13, 13);
INSERT INTO A (s, t) VALUES (14, 1);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 6);
INSERT INTO A (s, t) VALUES (14, 8);
INSERT INTO A (s, t) VALUES (14, 12);
INSERT INTO B (s, t) VALUES (15, 1);
INSERT INTO B (s, t) VALUES (15, 2);
INSERT INTO A (s, t) VALUES (15, 9);
INSERT INTO B (s, t) VALUES (15, 17);
INSERT INTO B (s, t) VALUES (16, 0);
INSERT INTO A (s, t) VALUES (16, 2);
INSERT INTO A (s, t) VALUES (16, 7);
INSERT INTO B (s, t) VALUES (16, 11);
INSERT INTO B (s, t) VALUES (16, 12);
INSERT INTO B (s, t) VALUES (16, 13);
INSERT INTO A (s, t) VALUES (16, 14);
INSERT INTO B (s, t) VALUES (16, 18);
INSERT INTO A (s, t) VALUES (17, 10);
INSERT INTO B (s, t) VALUES (17, 13);
INSERT INTO A (s, t) VALUES (17, 14);
INSERT INTO B (s, t) VALUES (17, 16);
INSERT INTO A (s, t) VALUES (17, 17);
INSERT INTO A (s, t) VALUES (18, 10);
INSERT INTO A (s, t) VALUES (18, 16);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
19,0.2,67,true,13:18:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (0, 14);
INSERT INTO B (s, t) VALUES (0, 16);
INSERT INTO A (s, t) VALUES (1, 1);
INSERT INTO A (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO B (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (3, 14);
INSERT INTO B (s, t) VALUES (4, 10);
INSERT INTO B (s, t) VALUES (4, 17);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO B (s, t) VALUES (5, 16);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 8);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (6, 15);
INSERT INTO A (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (7, 16);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 12);
INSERT INTO A (s, t) VALUES (9, 17);
INSERT INTO A (s, t) VALUES (10, 0);
INSERT INTO B (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO A (s, t) VALUES (10, 15);
INSERT INTO A (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 16);
INSERT INTO B (s, t) VALUES (11, 18);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO B (s, t) VALUES (12, 1);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO A (s, t) VALUES (12, 9);
INSERT INTO B (s, t) VALUES (13, 3);
INSERT INTO A (s, t) VALUES (13, 13);
INSERT INTO A (s, t) VALUES (14, 1);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 6);
INSERT INTO A (s, t) VALUES (14, 8);
INSERT INTO A (s, t) VALUES (14, 12);
INSERT INTO B (s, t) VALUES (15, 1);
INSERT INTO B (s, t) VALUES (15, 2);
INSERT INTO A (s, t) VALUES (15, 9);
INSERT INTO B (s, t) VALUES (15, 17);
INSERT INTO B (s, t) VALUES (16, 0);
INSERT INTO A (s, t) VALUES (16, 2);
INSERT INTO A (s, t) VALUES (16, 7);
INSERT INTO B (s, t) VALUES (16, 11);
INSERT INTO B (s, t) VALUES (16, 12);
INSERT INTO B (s, t) VALUES (16, 13);
INSERT INTO A (s, t) VALUES (16, 14);
INSERT INTO B (s, t) VALUES (16, 18);
INSERT INTO A (s, t) VALUES (17, 10);
INSERT INTO B (s, t) VALUES (17, 13);
INSERT INTO A (s, t) VALUES (17, 14);
INSERT INTO B (s, t) VALUES (17, 16);
INSERT INTO A (s, t) VALUES (17, 17);
INSERT INTO A (s, t) VALUES (18, 10);
INSERT INTO A (s, t) VALUES (18, 16);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
19,0.2,timeout,false,13:28:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO A (s, t) VALUES (0, 14);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (1, 12);
INSERT INTO A (s, t) VALUES (1, 17);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 17);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 14);
INSERT INTO B (s, t) VALUES (3, 15);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (4, 15);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 13);
INSERT INTO A (s, t) VALUES (6, 16);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (7, 13);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (8, 13);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (10, 13);
INSERT INTO B (s, t) VALUES (10, 15);
INSERT INTO A (s, t) VALUES (10, 18);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 14);
INSERT INTO A (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 10);
INSERT INTO A (s, t) VALUES (13, 7);
INSERT INTO B (s, t) VALUES (14, 2);
INSERT INTO A (s, t) VALUES (14, 6);
INSERT INTO B (s, t) VALUES (14, 12);
INSERT INTO B (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 7);
INSERT INTO B (s, t) VALUES (15, 9);
INSERT INTO B (s, t) VALUES (15, 16);
INSERT INTO A (s, t) VALUES (16, 7);
INSERT INTO A (s, t) VALUES (16, 18);
INSERT INTO B (s, t) VALUES (17, 6);
INSERT INTO A (s, t) VALUES (17, 10);
INSERT INTO B (s, t) VALUES (17, 13);
INSERT INTO A (s, t) VALUES (17, 14);
INSERT INTO A (s, t) VALUES (17, 16);
INSERT INTO B (s, t) VALUES (18, 3);
INSERT INTO A (s, t) VALUES (18, 9);
INSERT INTO A (s, t) VALUES (18, 10);
INSERT INTO B (s, t) VALUES (18, 12);
INSERT INTO A (s, t) VALUES (18, 15);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
19,0.2,timeout,false,13:33:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO A (s, t) VALUES (0, 14);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (1, 12);
INSERT INTO A (s, t) VALUES (1, 17);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 17);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 14);
INSERT INTO B (s, t) VALUES (3, 15);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (4, 15);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 13);
INSERT INTO A (s, t) VALUES (6, 16);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (7, 13);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (8, 13);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (10, 13);
INSERT INTO B (s, t) VALUES (10, 15);
INSERT INTO A (s, t) VALUES (10, 18);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 14);
INSERT INTO A (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 10);
INSERT INTO A (s, t) VALUES (13, 7);
INSERT INTO B (s, t) VALUES (14, 2);
INSERT INTO A (s, t) VALUES (14, 6);
INSERT INTO B (s, t) VALUES (14, 12);
INSERT INTO B (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 7);
INSERT INTO B (s, t) VALUES (15, 9);
INSERT INTO B (s, t) VALUES (15, 16);
INSERT INTO A (s, t) VALUES (16, 7);
INSERT INTO A (s, t) VALUES (16, 18);
INSERT INTO B (s, t) VALUES (17, 6);
INSERT INTO A (s, t) VALUES (17, 10);
INSERT INTO B (s, t) VALUES (17, 13);
INSERT INTO A (s, t) VALUES (17, 14);
INSERT INTO A (s, t) VALUES (17, 16);
INSERT INTO B (s, t) VALUES (18, 3);
INSERT INTO A (s, t) VALUES (18, 9);
INSERT INTO A (s, t) VALUES (18, 10);
INSERT INTO B (s, t) VALUES (18, 12);
INSERT INTO A (s, t) VALUES (18, 15);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
19,0.2,timeout,false,13:38:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO A (s, t) VALUES (0, 14);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (1, 12);
INSERT INTO A (s, t) VALUES (1, 17);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 17);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 14);
INSERT INTO B (s, t) VALUES (3, 15);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (4, 15);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 13);
INSERT INTO A (s, t) VALUES (6, 16);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (7, 13);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (8, 13);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (10, 13);
INSERT INTO B (s, t) VALUES (10, 15);
INSERT INTO A (s, t) VALUES (10, 18);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 14);
INSERT INTO A (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 10);
INSERT INTO A (s, t) VALUES (13, 7);
INSERT INTO B (s, t) VALUES (14, 2);
INSERT INTO A (s, t) VALUES (14, 6);
INSERT INTO B (s, t) VALUES (14, 12);
INSERT INTO B (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 7);
INSERT INTO B (s, t) VALUES (15, 9);
INSERT INTO B (s, t) VALUES (15, 16);
INSERT INTO A (s, t) VALUES (16, 7);
INSERT INTO A (s, t) VALUES (16, 18);
INSERT INTO B (s, t) VALUES (17, 6);
INSERT INTO A (s, t) VALUES (17, 10);
INSERT INTO B (s, t) VALUES (17, 13);
INSERT INTO A (s, t) VALUES (17, 14);
INSERT INTO A (s, t) VALUES (17, 16);
INSERT INTO B (s, t) VALUES (18, 3);
INSERT INTO A (s, t) VALUES (18, 9);
INSERT INTO A (s, t) VALUES (18, 10);
INSERT INTO B (s, t) VALUES (18, 12);
INSERT INTO A (s, t) VALUES (18, 15);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
19,0.2,timeout,false,13:43:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO A (s, t) VALUES (0, 14);
INSERT INTO A (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 5);
INSERT INTO A (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (1, 12);
INSERT INTO A (s, t) VALUES (1, 17);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO A (s, t) VALUES (2, 3);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO B (s, t) VALUES (2, 17);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO A (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 14);
INSERT INTO B (s, t) VALUES (3, 15);
INSERT INTO A (s, t) VALUES (4, 8);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (4, 15);
INSERT INTO A (s, t) VALUES (5, 2);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 10);
INSERT INTO A (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 13);
INSERT INTO A (s, t) VALUES (6, 16);
INSERT INTO B (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 11);
INSERT INTO B (s, t) VALUES (7, 13);
INSERT INTO A (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO B (s, t) VALUES (8, 7);
INSERT INTO B (s, t) VALUES (8, 10);
INSERT INTO A (s, t) VALUES (8, 13);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 8);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (10, 10);
INSERT INTO B (s, t) VALUES (10, 13);
INSERT INTO B (s, t) VALUES (10, 15);
INSERT INTO A (s, t) VALUES (10, 18);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO B (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 6);
INSERT INTO B (s, t) VALUES (11, 11);
INSERT INTO A (s, t) VALUES (11, 14);
INSERT INTO A (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 10);
INSERT INTO A (s, t) VALUES (13, 7);
INSERT INTO B (s, t) VALUES (14, 2);
INSERT INTO A (s, t) VALUES (14, 6);
INSERT INTO B (s, t) VALUES (14, 12);
INSERT INTO B (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 7);
INSERT INTO B (s, t) VALUES (15, 9);
INSERT INTO B (s, t) VALUES (15, 16);
INSERT INTO A (s, t) VALUES (16, 7);
INSERT INTO A (s, t) VALUES (16, 18);
INSERT INTO B (s, t) VALUES (17, 6);
INSERT INTO A (s, t) VALUES (17, 10);
INSERT INTO B (s, t) VALUES (17, 13);
INSERT INTO A (s, t) VALUES (17, 14);
INSERT INTO A (s, t) VALUES (17, 16);
INSERT INTO B (s, t) VALUES (18, 3);
INSERT INTO A (s, t) VALUES (18, 9);
INSERT INTO A (s, t) VALUES (18, 10);
INSERT INTO B (s, t) VALUES (18, 12);
INSERT INTO A (s, t) VALUES (18, 15);
INSERT INTO StartLabel VALUES (7)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
19,0.2,timeout,false,13:53:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 14);
INSERT INTO B (s, t) VALUES (1, 15);
INSERT INTO B (s, t) VALUES (1, 16);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO A (s, t) VALUES (3, 15);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 16);
INSERT INTO B (s, t) VALUES (4, 17);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 11);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (5, 17);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (7, 13);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 12);
INSERT INTO A (s, t) VALUES (8, 14);
INSERT INTO B (s, t) VALUES (8, 16);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 11);
INSERT INTO A (s, t) VALUES (10, 16);
INSERT INTO A (s, t) VALUES (10, 17);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (11, 14);
INSERT INTO A (s, t) VALUES (11, 16);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 8);
INSERT INTO A (s, t) VALUES (12, 13);
INSERT INTO B (s, t) VALUES (12, 14);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO A (s, t) VALUES (13, 2);
INSERT INTO B (s, t) VALUES (13, 4);
INSERT INTO B (s, t) VALUES (13, 13);
INSERT INTO A (s, t) VALUES (13, 17);
INSERT INTO B (s, t) VALUES (14, 2);
INSERT INTO A (s, t) VALUES (14, 3);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 4);
INSERT INTO B (s, t) VALUES (16, 4);
INSERT INTO A (s, t) VALUES (16, 8);
INSERT INTO A (s, t) VALUES (16, 13);
INSERT INTO A (s, t) VALUES (16, 18);
INSERT INTO A (s, t) VALUES (17, 1);
INSERT INTO A (s, t) VALUES (17, 3);
INSERT INTO A (s, t) VALUES (17, 15);
INSERT INTO A (s, t) VALUES (17, 16);
INSERT INTO A (s, t) VALUES (18, 14);
INSERT INTO B (s, t) VALUES (18, 15);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
19,0.2,timeout,false,13:58:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 14);
INSERT INTO B (s, t) VALUES (1, 15);
INSERT INTO B (s, t) VALUES (1, 16);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO A (s, t) VALUES (3, 15);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 16);
INSERT INTO B (s, t) VALUES (4, 17);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 11);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (5, 17);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (7, 13);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 12);
INSERT INTO A (s, t) VALUES (8, 14);
INSERT INTO B (s, t) VALUES (8, 16);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 11);
INSERT INTO A (s, t) VALUES (10, 16);
INSERT INTO A (s, t) VALUES (10, 17);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (11, 14);
INSERT INTO A (s, t) VALUES (11, 16);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 8);
INSERT INTO A (s, t) VALUES (12, 13);
INSERT INTO B (s, t) VALUES (12, 14);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO A (s, t) VALUES (13, 2);
INSERT INTO B (s, t) VALUES (13, 4);
INSERT INTO B (s, t) VALUES (13, 13);
INSERT INTO A (s, t) VALUES (13, 17);
INSERT INTO B (s, t) VALUES (14, 2);
INSERT INTO A (s, t) VALUES (14, 3);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 4);
INSERT INTO B (s, t) VALUES (16, 4);
INSERT INTO A (s, t) VALUES (16, 8);
INSERT INTO A (s, t) VALUES (16, 13);
INSERT INTO A (s, t) VALUES (16, 18);
INSERT INTO A (s, t) VALUES (17, 1);
INSERT INTO A (s, t) VALUES (17, 3);
INSERT INTO A (s, t) VALUES (17, 15);
INSERT INTO A (s, t) VALUES (17, 16);
INSERT INTO A (s, t) VALUES (18, 14);
INSERT INTO B (s, t) VALUES (18, 15);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
19,0.2,timeout,false,14:03:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 14);
INSERT INTO B (s, t) VALUES (1, 15);
INSERT INTO B (s, t) VALUES (1, 16);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO A (s, t) VALUES (3, 15);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 16);
INSERT INTO B (s, t) VALUES (4, 17);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 11);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (5, 17);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (7, 13);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 12);
INSERT INTO A (s, t) VALUES (8, 14);
INSERT INTO B (s, t) VALUES (8, 16);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 11);
INSERT INTO A (s, t) VALUES (10, 16);
INSERT INTO A (s, t) VALUES (10, 17);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (11, 14);
INSERT INTO A (s, t) VALUES (11, 16);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 8);
INSERT INTO A (s, t) VALUES (12, 13);
INSERT INTO B (s, t) VALUES (12, 14);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO A (s, t) VALUES (13, 2);
INSERT INTO B (s, t) VALUES (13, 4);
INSERT INTO B (s, t) VALUES (13, 13);
INSERT INTO A (s, t) VALUES (13, 17);
INSERT INTO B (s, t) VALUES (14, 2);
INSERT INTO A (s, t) VALUES (14, 3);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 4);
INSERT INTO B (s, t) VALUES (16, 4);
INSERT INTO A (s, t) VALUES (16, 8);
INSERT INTO A (s, t) VALUES (16, 13);
INSERT INTO A (s, t) VALUES (16, 18);
INSERT INTO A (s, t) VALUES (17, 1);
INSERT INTO A (s, t) VALUES (17, 3);
INSERT INTO A (s, t) VALUES (17, 15);
INSERT INTO A (s, t) VALUES (17, 16);
INSERT INTO A (s, t) VALUES (18, 14);
INSERT INTO B (s, t) VALUES (18, 15);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
19,0.2,timeout,false,14:08:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 2);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO A (s, t) VALUES (1, 7);
INSERT INTO A (s, t) VALUES (1, 14);
INSERT INTO B (s, t) VALUES (1, 15);
INSERT INTO B (s, t) VALUES (1, 16);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (3, 0);
INSERT INTO A (s, t) VALUES (3, 7);
INSERT INTO A (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 9);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO A (s, t) VALUES (3, 15);
INSERT INTO A (s, t) VALUES (4, 4);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 16);
INSERT INTO B (s, t) VALUES (4, 17);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 11);
INSERT INTO A (s, t) VALUES (5, 12);
INSERT INTO B (s, t) VALUES (5, 17);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO A (s, t) VALUES (7, 13);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO A (s, t) VALUES (8, 12);
INSERT INTO A (s, t) VALUES (8, 14);
INSERT INTO B (s, t) VALUES (8, 16);
INSERT INTO A (s, t) VALUES (9, 0);
INSERT INTO A (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 7);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 11);
INSERT INTO A (s, t) VALUES (10, 16);
INSERT INTO A (s, t) VALUES (10, 17);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO A (s, t) VALUES (11, 12);
INSERT INTO B (s, t) VALUES (11, 14);
INSERT INTO A (s, t) VALUES (11, 16);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 8);
INSERT INTO A (s, t) VALUES (12, 13);
INSERT INTO B (s, t) VALUES (12, 14);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO A (s, t) VALUES (13, 2);
INSERT INTO B (s, t) VALUES (13, 4);
INSERT INTO B (s, t) VALUES (13, 13);
INSERT INTO A (s, t) VALUES (13, 17);
INSERT INTO B (s, t) VALUES (14, 2);
INSERT INTO A (s, t) VALUES (14, 3);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 4);
INSERT INTO B (s, t) VALUES (16, 4);
INSERT INTO A (s, t) VALUES (16, 8);
INSERT INTO A (s, t) VALUES (16, 13);
INSERT INTO A (s, t) VALUES (16, 18);
INSERT INTO A (s, t) VALUES (17, 1);
INSERT INTO A (s, t) VALUES (17, 3);
INSERT INTO A (s, t) VALUES (17, 15);
INSERT INTO A (s, t) VALUES (17, 16);
INSERT INTO A (s, t) VALUES (18, 14);
INSERT INTO B (s, t) VALUES (18, 15);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (6)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
19,0.2,25,true,14:08:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (0, 16);
INSERT INTO B (s, t) VALUES (0, 17);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 15);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 12);
INSERT INTO A (s, t) VALUES (3, 18);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO B (s, t) VALUES (5, 14);
INSERT INTO A (s, t) VALUES (5, 17);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 13);
INSERT INTO A (s, t) VALUES (6, 14);
INSERT INTO A (s, t) VALUES (6, 17);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 12);
INSERT INTO A (s, t) VALUES (8, 13);
INSERT INTO B (s, t) VALUES (8, 18);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (9, 17);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO A (s, t) VALUES (10, 15);
INSERT INTO A (s, t) VALUES (10, 17);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 18);
INSERT INTO A (s, t) VALUES (12, 11);
INSERT INTO A (s, t) VALUES (12, 14);
INSERT INTO B (s, t) VALUES (12, 18);
INSERT INTO B (s, t) VALUES (13, 1);
INSERT INTO B (s, t) VALUES (13, 14);
INSERT INTO B (s, t) VALUES (14, 6);
INSERT INTO B (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 7);
INSERT INTO B (s, t) VALUES (15, 16);
INSERT INTO B (s, t) VALUES (16, 0);
INSERT INTO B (s, t) VALUES (16, 9);
INSERT INTO A (s, t) VALUES (16, 12);
INSERT INTO A (s, t) VALUES (17, 1);
INSERT INTO A (s, t) VALUES (17, 6);
INSERT INTO B (s, t) VALUES (18, 0);
INSERT INTO B (s, t) VALUES (18, 3);
INSERT INTO B (s, t) VALUES (18, 10);
INSERT INTO B (s, t) VALUES (18, 12);
INSERT INTO A (s, t) VALUES (18, 14);
INSERT INTO A (s, t) VALUES (18, 18);
INSERT INTO StartLabel VALUES (9)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
19,0.2,25,true,14:08:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (0, 16);
INSERT INTO B (s, t) VALUES (0, 17);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 15);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 12);
INSERT INTO A (s, t) VALUES (3, 18);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO B (s, t) VALUES (5, 14);
INSERT INTO A (s, t) VALUES (5, 17);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 13);
INSERT INTO A (s, t) VALUES (6, 14);
INSERT INTO A (s, t) VALUES (6, 17);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 12);
INSERT INTO A (s, t) VALUES (8, 13);
INSERT INTO B (s, t) VALUES (8, 18);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (9, 17);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO A (s, t) VALUES (10, 15);
INSERT INTO A (s, t) VALUES (10, 17);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 18);
INSERT INTO A (s, t) VALUES (12, 11);
INSERT INTO A (s, t) VALUES (12, 14);
INSERT INTO B (s, t) VALUES (12, 18);
INSERT INTO B (s, t) VALUES (13, 1);
INSERT INTO B (s, t) VALUES (13, 14);
INSERT INTO B (s, t) VALUES (14, 6);
INSERT INTO B (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 7);
INSERT INTO B (s, t) VALUES (15, 16);
INSERT INTO B (s, t) VALUES (16, 0);
INSERT INTO B (s, t) VALUES (16, 9);
INSERT INTO A (s, t) VALUES (16, 12);
INSERT INTO A (s, t) VALUES (17, 1);
INSERT INTO A (s, t) VALUES (17, 6);
INSERT INTO B (s, t) VALUES (18, 0);
INSERT INTO B (s, t) VALUES (18, 3);
INSERT INTO B (s, t) VALUES (18, 10);
INSERT INTO B (s, t) VALUES (18, 12);
INSERT INTO A (s, t) VALUES (18, 14);
INSERT INTO A (s, t) VALUES (18, 18);
INSERT INTO StartLabel VALUES (9)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
19,0.2,25,true,14:08:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (0, 16);
INSERT INTO B (s, t) VALUES (0, 17);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 15);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 12);
INSERT INTO A (s, t) VALUES (3, 18);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO B (s, t) VALUES (5, 14);
INSERT INTO A (s, t) VALUES (5, 17);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 13);
INSERT INTO A (s, t) VALUES (6, 14);
INSERT INTO A (s, t) VALUES (6, 17);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 12);
INSERT INTO A (s, t) VALUES (8, 13);
INSERT INTO B (s, t) VALUES (8, 18);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (9, 17);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO A (s, t) VALUES (10, 15);
INSERT INTO A (s, t) VALUES (10, 17);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 18);
INSERT INTO A (s, t) VALUES (12, 11);
INSERT INTO A (s, t) VALUES (12, 14);
INSERT INTO B (s, t) VALUES (12, 18);
INSERT INTO B (s, t) VALUES (13, 1);
INSERT INTO B (s, t) VALUES (13, 14);
INSERT INTO B (s, t) VALUES (14, 6);
INSERT INTO B (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 7);
INSERT INTO B (s, t) VALUES (15, 16);
INSERT INTO B (s, t) VALUES (16, 0);
INSERT INTO B (s, t) VALUES (16, 9);
INSERT INTO A (s, t) VALUES (16, 12);
INSERT INTO A (s, t) VALUES (17, 1);
INSERT INTO A (s, t) VALUES (17, 6);
INSERT INTO B (s, t) VALUES (18, 0);
INSERT INTO B (s, t) VALUES (18, 3);
INSERT INTO B (s, t) VALUES (18, 10);
INSERT INTO B (s, t) VALUES (18, 12);
INSERT INTO A (s, t) VALUES (18, 14);
INSERT INTO A (s, t) VALUES (18, 18);
INSERT INTO StartLabel VALUES (9)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
19,0.2,25,true,14:08:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 7);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (0, 16);
INSERT INTO B (s, t) VALUES (0, 17);
INSERT INTO B (s, t) VALUES (1, 0);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 3);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 15);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 12);
INSERT INTO A (s, t) VALUES (3, 18);
INSERT INTO B (s, t) VALUES (4, 0);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (5, 4);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO B (s, t) VALUES (5, 14);
INSERT INTO A (s, t) VALUES (5, 17);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 13);
INSERT INTO A (s, t) VALUES (6, 14);
INSERT INTO A (s, t) VALUES (6, 17);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 7);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 5);
INSERT INTO A (s, t) VALUES (8, 12);
INSERT INTO A (s, t) VALUES (8, 13);
INSERT INTO B (s, t) VALUES (8, 18);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 8);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (9, 17);
INSERT INTO A (s, t) VALUES (10, 9);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO A (s, t) VALUES (10, 15);
INSERT INTO A (s, t) VALUES (10, 17);
INSERT INTO A (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (11, 18);
INSERT INTO A (s, t) VALUES (12, 11);
INSERT INTO A (s, t) VALUES (12, 14);
INSERT INTO B (s, t) VALUES (12, 18);
INSERT INTO B (s, t) VALUES (13, 1);
INSERT INTO B (s, t) VALUES (13, 14);
INSERT INTO B (s, t) VALUES (14, 6);
INSERT INTO B (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 7);
INSERT INTO B (s, t) VALUES (15, 16);
INSERT INTO B (s, t) VALUES (16, 0);
INSERT INTO B (s, t) VALUES (16, 9);
INSERT INTO A (s, t) VALUES (16, 12);
INSERT INTO A (s, t) VALUES (17, 1);
INSERT INTO A (s, t) VALUES (17, 6);
INSERT INTO B (s, t) VALUES (18, 0);
INSERT INTO B (s, t) VALUES (18, 3);
INSERT INTO B (s, t) VALUES (18, 10);
INSERT INTO B (s, t) VALUES (18, 12);
INSERT INTO A (s, t) VALUES (18, 14);
INSERT INTO A (s, t) VALUES (18, 18);
INSERT INTO StartLabel VALUES (9)
INSERT INTO EndLabel VALUES (7)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
19,0.2,timeout,false,14:18:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (0, 15);
INSERT INTO B (s, t) VALUES (0, 17);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 16);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 14);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO A (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO A (s, t) VALUES (5, 16);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 14);
INSERT INTO A (s, t) VALUES (6, 15);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (8, 15);
INSERT INTO A (s, t) VALUES (8, 16);
INSERT INTO B (s, t) VALUES (8, 18);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (9, 14);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO B (s, t) VALUES (10, 14);
INSERT INTO A (s, t) VALUES (10, 16);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 14);
INSERT INTO B (s, t) VALUES (11, 16);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 6);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO B (s, t) VALUES (12, 15);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO A (s, t) VALUES (13, 2);
INSERT INTO A (s, t) VALUES (13, 6);
INSERT INTO B (s, t) VALUES (13, 7);
INSERT INTO A (s, t) VALUES (13, 10);
INSERT INTO B (s, t) VALUES (13, 17);
INSERT INTO A (s, t) VALUES (14, 7);
INSERT INTO B (s, t) VALUES (14, 18);
INSERT INTO B (s, t) VALUES (15, 6);
INSERT INTO B (s, t) VALUES (15, 8);
INSERT INTO B (s, t) VALUES (15, 14);
INSERT INTO B (s, t) VALUES (15, 18);
INSERT INTO B (s, t) VALUES (16, 10);
INSERT INTO A (s, t) VALUES (16, 14);
INSERT INTO B (s, t) VALUES (16, 17);
INSERT INTO A (s, t) VALUES (17, 0);
INSERT INTO A (s, t) VALUES (17, 2);
INSERT INTO A (s, t) VALUES (17, 9);
INSERT INTO B (s, t) VALUES (17, 13);
INSERT INTO B (s, t) VALUES (17, 15);
INSERT INTO A (s, t) VALUES (17, 18);
INSERT INTO B (s, t) VALUES (18, 0);
INSERT INTO A (s, t) VALUES (18, 1);
INSERT INTO A (s, t) VALUES (18, 5);
INSERT INTO B (s, t) VALUES (18, 10);
INSERT INTO A (s, t) VALUES (18, 11);
INSERT INTO B (s, t) VALUES (18, 17);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (12)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
19,0.2,timeout,false,14:23:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (0, 15);
INSERT INTO B (s, t) VALUES (0, 17);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 16);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 14);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO A (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO A (s, t) VALUES (5, 16);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 14);
INSERT INTO A (s, t) VALUES (6, 15);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (8, 15);
INSERT INTO A (s, t) VALUES (8, 16);
INSERT INTO B (s, t) VALUES (8, 18);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (9, 14);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO B (s, t) VALUES (10, 14);
INSERT INTO A (s, t) VALUES (10, 16);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 14);
INSERT INTO B (s, t) VALUES (11, 16);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 6);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO B (s, t) VALUES (12, 15);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO A (s, t) VALUES (13, 2);
INSERT INTO A (s, t) VALUES (13, 6);
INSERT INTO B (s, t) VALUES (13, 7);
INSERT INTO A (s, t) VALUES (13, 10);
INSERT INTO B (s, t) VALUES (13, 17);
INSERT INTO A (s, t) VALUES (14, 7);
INSERT INTO B (s, t) VALUES (14, 18);
INSERT INTO B (s, t) VALUES (15, 6);
INSERT INTO B (s, t) VALUES (15, 8);
INSERT INTO B (s, t) VALUES (15, 14);
INSERT INTO B (s, t) VALUES (15, 18);
INSERT INTO B (s, t) VALUES (16, 10);
INSERT INTO A (s, t) VALUES (16, 14);
INSERT INTO B (s, t) VALUES (16, 17);
INSERT INTO A (s, t) VALUES (17, 0);
INSERT INTO A (s, t) VALUES (17, 2);
INSERT INTO A (s, t) VALUES (17, 9);
INSERT INTO B (s, t) VALUES (17, 13);
INSERT INTO B (s, t) VALUES (17, 15);
INSERT INTO A (s, t) VALUES (17, 18);
INSERT INTO B (s, t) VALUES (18, 0);
INSERT INTO A (s, t) VALUES (18, 1);
INSERT INTO A (s, t) VALUES (18, 5);
INSERT INTO B (s, t) VALUES (18, 10);
INSERT INTO A (s, t) VALUES (18, 11);
INSERT INTO B (s, t) VALUES (18, 17);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (12)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
19,0.2,timeout,false,14:28:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (0, 15);
INSERT INTO B (s, t) VALUES (0, 17);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 16);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 14);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO A (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO A (s, t) VALUES (5, 16);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 14);
INSERT INTO A (s, t) VALUES (6, 15);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (8, 15);
INSERT INTO A (s, t) VALUES (8, 16);
INSERT INTO B (s, t) VALUES (8, 18);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (9, 14);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO B (s, t) VALUES (10, 14);
INSERT INTO A (s, t) VALUES (10, 16);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 14);
INSERT INTO B (s, t) VALUES (11, 16);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 6);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO B (s, t) VALUES (12, 15);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO A (s, t) VALUES (13, 2);
INSERT INTO A (s, t) VALUES (13, 6);
INSERT INTO B (s, t) VALUES (13, 7);
INSERT INTO A (s, t) VALUES (13, 10);
INSERT INTO B (s, t) VALUES (13, 17);
INSERT INTO A (s, t) VALUES (14, 7);
INSERT INTO B (s, t) VALUES (14, 18);
INSERT INTO B (s, t) VALUES (15, 6);
INSERT INTO B (s, t) VALUES (15, 8);
INSERT INTO B (s, t) VALUES (15, 14);
INSERT INTO B (s, t) VALUES (15, 18);
INSERT INTO B (s, t) VALUES (16, 10);
INSERT INTO A (s, t) VALUES (16, 14);
INSERT INTO B (s, t) VALUES (16, 17);
INSERT INTO A (s, t) VALUES (17, 0);
INSERT INTO A (s, t) VALUES (17, 2);
INSERT INTO A (s, t) VALUES (17, 9);
INSERT INTO B (s, t) VALUES (17, 13);
INSERT INTO B (s, t) VALUES (17, 15);
INSERT INTO A (s, t) VALUES (17, 18);
INSERT INTO B (s, t) VALUES (18, 0);
INSERT INTO A (s, t) VALUES (18, 1);
INSERT INTO A (s, t) VALUES (18, 5);
INSERT INTO B (s, t) VALUES (18, 10);
INSERT INTO A (s, t) VALUES (18, 11);
INSERT INTO B (s, t) VALUES (18, 17);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (12)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
19,0.2,timeout,false,14:33:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (0, 15);
INSERT INTO B (s, t) VALUES (0, 17);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO A (s, t) VALUES (1, 10);
INSERT INTO A (s, t) VALUES (1, 16);
INSERT INTO A (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO B (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 8);
INSERT INTO A (s, t) VALUES (2, 14);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 13);
INSERT INTO B (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 9);
INSERT INTO A (s, t) VALUES (4, 10);
INSERT INTO A (s, t) VALUES (4, 11);
INSERT INTO B (s, t) VALUES (5, 4);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (5, 13);
INSERT INTO A (s, t) VALUES (5, 16);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 14);
INSERT INTO A (s, t) VALUES (6, 15);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 4);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (8, 15);
INSERT INTO A (s, t) VALUES (8, 16);
INSERT INTO B (s, t) VALUES (8, 18);
INSERT INTO B (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO A (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (9, 14);
INSERT INTO A (s, t) VALUES (10, 2);
INSERT INTO A (s, t) VALUES (10, 4);
INSERT INTO B (s, t) VALUES (10, 6);
INSERT INTO A (s, t) VALUES (10, 7);
INSERT INTO B (s, t) VALUES (10, 14);
INSERT INTO A (s, t) VALUES (10, 16);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 14);
INSERT INTO B (s, t) VALUES (11, 16);
INSERT INTO B (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 4);
INSERT INTO B (s, t) VALUES (12, 6);
INSERT INTO B (s, t) VALUES (12, 9);
INSERT INTO B (s, t) VALUES (12, 15);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO A (s, t) VALUES (13, 2);
INSERT INTO A (s, t) VALUES (13, 6);
INSERT INTO B (s, t) VALUES (13, 7);
INSERT INTO A (s, t) VALUES (13, 10);
INSERT INTO B (s, t) VALUES (13, 17);
INSERT INTO A (s, t) VALUES (14, 7);
INSERT INTO B (s, t) VALUES (14, 18);
INSERT INTO B (s, t) VALUES (15, 6);
INSERT INTO B (s, t) VALUES (15, 8);
INSERT INTO B (s, t) VALUES (15, 14);
INSERT INTO B (s, t) VALUES (15, 18);
INSERT INTO B (s, t) VALUES (16, 10);
INSERT INTO A (s, t) VALUES (16, 14);
INSERT INTO B (s, t) VALUES (16, 17);
INSERT INTO A (s, t) VALUES (17, 0);
INSERT INTO A (s, t) VALUES (17, 2);
INSERT INTO A (s, t) VALUES (17, 9);
INSERT INTO B (s, t) VALUES (17, 13);
INSERT INTO B (s, t) VALUES (17, 15);
INSERT INTO A (s, t) VALUES (17, 18);
INSERT INTO B (s, t) VALUES (18, 0);
INSERT INTO A (s, t) VALUES (18, 1);
INSERT INTO A (s, t) VALUES (18, 5);
INSERT INTO B (s, t) VALUES (18, 10);
INSERT INTO A (s, t) VALUES (18, 11);
INSERT INTO B (s, t) VALUES (18, 17);
INSERT INTO StartLabel VALUES (3)
INSERT INTO EndLabel VALUES (12)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
20,0.2,timeout,false,14:43:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (0, 14);
INSERT INTO A (s, t) VALUES (0, 15);
INSERT INTO B (s, t) VALUES (0, 19);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (1, 13);
INSERT INTO A (s, t) VALUES (1, 15);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 11);
INSERT INTO B (s, t) VALUES (3, 15);
INSERT INTO A (s, t) VALUES (3, 16);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 17);
INSERT INTO B (s, t) VALUES (5, 18);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (6, 12);
INSERT INTO A (s, t) VALUES (6, 14);
INSERT INTO A (s, t) VALUES (6, 17);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (7, 12);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (9, 19);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO A (s, t) VALUES (10, 15);
INSERT INTO A (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 17);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (13, 9);
INSERT INTO B (s, t) VALUES (13, 16);
INSERT INTO A (s, t) VALUES (13, 18);
INSERT INTO A (s, t) VALUES (13, 19);
INSERT INTO A (s, t) VALUES (14, 17);
INSERT INTO A (s, t) VALUES (14, 19);
INSERT INTO B (s, t) VALUES (15, 2);
INSERT INTO B (s, t) VALUES (15, 5);
INSERT INTO B (s, t) VALUES (15, 11);
INSERT INTO B (s, t) VALUES (15, 12);
INSERT INTO B (s, t) VALUES (16, 8);
INSERT INTO A (s, t) VALUES (17, 0);
INSERT INTO A (s, t) VALUES (17, 2);
INSERT INTO A (s, t) VALUES (17, 9);
INSERT INTO A (s, t) VALUES (17, 16);
INSERT INTO B (s, t) VALUES (18, 2);
INSERT INTO B (s, t) VALUES (18, 5);
INSERT INTO B (s, t) VALUES (18, 8);
INSERT INTO A (s, t) VALUES (18, 12);
INSERT INTO A (s, t) VALUES (18, 14);
INSERT INTO B (s, t) VALUES (18, 15);
INSERT INTO A (s, t) VALUES (18, 16);
INSERT INTO A (s, t) VALUES (19, 8);
INSERT INTO B (s, t) VALUES (19, 9);
INSERT INTO B (s, t) VALUES (19, 16);
INSERT INTO A (s, t) VALUES (19, 19);
INSERT INTO StartLabel VALUES (19)
INSERT INTO EndLabel VALUES (14)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
20,0.2,timeout,false,14:48:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (0, 14);
INSERT INTO A (s, t) VALUES (0, 15);
INSERT INTO B (s, t) VALUES (0, 19);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (1, 13);
INSERT INTO A (s, t) VALUES (1, 15);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 11);
INSERT INTO B (s, t) VALUES (3, 15);
INSERT INTO A (s, t) VALUES (3, 16);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 17);
INSERT INTO B (s, t) VALUES (5, 18);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (6, 12);
INSERT INTO A (s, t) VALUES (6, 14);
INSERT INTO A (s, t) VALUES (6, 17);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (7, 12);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (9, 19);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO A (s, t) VALUES (10, 15);
INSERT INTO A (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 17);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (13, 9);
INSERT INTO B (s, t) VALUES (13, 16);
INSERT INTO A (s, t) VALUES (13, 18);
INSERT INTO A (s, t) VALUES (13, 19);
INSERT INTO A (s, t) VALUES (14, 17);
INSERT INTO A (s, t) VALUES (14, 19);
INSERT INTO B (s, t) VALUES (15, 2);
INSERT INTO B (s, t) VALUES (15, 5);
INSERT INTO B (s, t) VALUES (15, 11);
INSERT INTO B (s, t) VALUES (15, 12);
INSERT INTO B (s, t) VALUES (16, 8);
INSERT INTO A (s, t) VALUES (17, 0);
INSERT INTO A (s, t) VALUES (17, 2);
INSERT INTO A (s, t) VALUES (17, 9);
INSERT INTO A (s, t) VALUES (17, 16);
INSERT INTO B (s, t) VALUES (18, 2);
INSERT INTO B (s, t) VALUES (18, 5);
INSERT INTO B (s, t) VALUES (18, 8);
INSERT INTO A (s, t) VALUES (18, 12);
INSERT INTO A (s, t) VALUES (18, 14);
INSERT INTO B (s, t) VALUES (18, 15);
INSERT INTO A (s, t) VALUES (18, 16);
INSERT INTO A (s, t) VALUES (19, 8);
INSERT INTO B (s, t) VALUES (19, 9);
INSERT INTO B (s, t) VALUES (19, 16);
INSERT INTO A (s, t) VALUES (19, 19);
INSERT INTO StartLabel VALUES (19)
INSERT INTO EndLabel VALUES (14)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
20,0.2,timeout,false,14:53:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (0, 14);
INSERT INTO A (s, t) VALUES (0, 15);
INSERT INTO B (s, t) VALUES (0, 19);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (1, 13);
INSERT INTO A (s, t) VALUES (1, 15);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 11);
INSERT INTO B (s, t) VALUES (3, 15);
INSERT INTO A (s, t) VALUES (3, 16);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 17);
INSERT INTO B (s, t) VALUES (5, 18);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (6, 12);
INSERT INTO A (s, t) VALUES (6, 14);
INSERT INTO A (s, t) VALUES (6, 17);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (7, 12);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (9, 19);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO A (s, t) VALUES (10, 15);
INSERT INTO A (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 17);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (13, 9);
INSERT INTO B (s, t) VALUES (13, 16);
INSERT INTO A (s, t) VALUES (13, 18);
INSERT INTO A (s, t) VALUES (13, 19);
INSERT INTO A (s, t) VALUES (14, 17);
INSERT INTO A (s, t) VALUES (14, 19);
INSERT INTO B (s, t) VALUES (15, 2);
INSERT INTO B (s, t) VALUES (15, 5);
INSERT INTO B (s, t) VALUES (15, 11);
INSERT INTO B (s, t) VALUES (15, 12);
INSERT INTO B (s, t) VALUES (16, 8);
INSERT INTO A (s, t) VALUES (17, 0);
INSERT INTO A (s, t) VALUES (17, 2);
INSERT INTO A (s, t) VALUES (17, 9);
INSERT INTO A (s, t) VALUES (17, 16);
INSERT INTO B (s, t) VALUES (18, 2);
INSERT INTO B (s, t) VALUES (18, 5);
INSERT INTO B (s, t) VALUES (18, 8);
INSERT INTO A (s, t) VALUES (18, 12);
INSERT INTO A (s, t) VALUES (18, 14);
INSERT INTO B (s, t) VALUES (18, 15);
INSERT INTO A (s, t) VALUES (18, 16);
INSERT INTO A (s, t) VALUES (19, 8);
INSERT INTO B (s, t) VALUES (19, 9);
INSERT INTO B (s, t) VALUES (19, 16);
INSERT INTO A (s, t) VALUES (19, 19);
INSERT INTO StartLabel VALUES (19)
INSERT INTO EndLabel VALUES (14)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
20,0.2,timeout,false,14:58:42
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO B (s, t) VALUES (0, 6);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO B (s, t) VALUES (0, 14);
INSERT INTO A (s, t) VALUES (0, 15);
INSERT INTO B (s, t) VALUES (0, 19);
INSERT INTO B (s, t) VALUES (1, 2);
INSERT INTO B (s, t) VALUES (1, 4);
INSERT INTO B (s, t) VALUES (1, 10);
INSERT INTO B (s, t) VALUES (1, 13);
INSERT INTO A (s, t) VALUES (1, 15);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO A (s, t) VALUES (2, 7);
INSERT INTO A (s, t) VALUES (2, 9);
INSERT INTO B (s, t) VALUES (2, 13);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 11);
INSERT INTO B (s, t) VALUES (3, 15);
INSERT INTO A (s, t) VALUES (3, 16);
INSERT INTO A (s, t) VALUES (4, 2);
INSERT INTO A (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (4, 12);
INSERT INTO B (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (5, 0);
INSERT INTO A (s, t) VALUES (5, 1);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO B (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 17);
INSERT INTO B (s, t) VALUES (5, 18);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO B (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (6, 12);
INSERT INTO A (s, t) VALUES (6, 14);
INSERT INTO A (s, t) VALUES (6, 17);
INSERT INTO A (s, t) VALUES (7, 3);
INSERT INTO B (s, t) VALUES (7, 8);
INSERT INTO B (s, t) VALUES (7, 10);
INSERT INTO A (s, t) VALUES (7, 12);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO A (s, t) VALUES (8, 7);
INSERT INTO A (s, t) VALUES (9, 2);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO A (s, t) VALUES (9, 5);
INSERT INTO B (s, t) VALUES (9, 11);
INSERT INTO B (s, t) VALUES (9, 19);
INSERT INTO A (s, t) VALUES (10, 11);
INSERT INTO A (s, t) VALUES (10, 15);
INSERT INTO A (s, t) VALUES (11, 1);
INSERT INTO A (s, t) VALUES (12, 6);
INSERT INTO A (s, t) VALUES (12, 17);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (13, 9);
INSERT INTO B (s, t) VALUES (13, 16);
INSERT INTO A (s, t) VALUES (13, 18);
INSERT INTO A (s, t) VALUES (13, 19);
INSERT INTO A (s, t) VALUES (14, 17);
INSERT INTO A (s, t) VALUES (14, 19);
INSERT INTO B (s, t) VALUES (15, 2);
INSERT INTO B (s, t) VALUES (15, 5);
INSERT INTO B (s, t) VALUES (15, 11);
INSERT INTO B (s, t) VALUES (15, 12);
INSERT INTO B (s, t) VALUES (16, 8);
INSERT INTO A (s, t) VALUES (17, 0);
INSERT INTO A (s, t) VALUES (17, 2);
INSERT INTO A (s, t) VALUES (17, 9);
INSERT INTO A (s, t) VALUES (17, 16);
INSERT INTO B (s, t) VALUES (18, 2);
INSERT INTO B (s, t) VALUES (18, 5);
INSERT INTO B (s, t) VALUES (18, 8);
INSERT INTO A (s, t) VALUES (18, 12);
INSERT INTO A (s, t) VALUES (18, 14);
INSERT INTO B (s, t) VALUES (18, 15);
INSERT INTO A (s, t) VALUES (18, 16);
INSERT INTO A (s, t) VALUES (19, 8);
INSERT INTO B (s, t) VALUES (19, 9);
INSERT INTO B (s, t) VALUES (19, 16);
INSERT INTO A (s, t) VALUES (19, 19);
INSERT INTO StartLabel VALUES (19)
INSERT INTO EndLabel VALUES (14)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
20,0.2,41883,true,15:00:05
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO A (s, t) VALUES (0, 17);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 12);
INSERT INTO A (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (1, 19);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (2, 11);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 15);
INSERT INTO B (s, t) VALUES (3, 19);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (4, 13);
INSERT INTO A (s, t) VALUES (4, 14);
INSERT INTO A (s, t) VALUES (4, 19);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 13);
INSERT INTO A (s, t) VALUES (5, 15);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (6, 13);
INSERT INTO A (s, t) VALUES (6, 15);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 16);
INSERT INTO A (s, t) VALUES (7, 19);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 14);
INSERT INTO B (s, t) VALUES (8, 15);
INSERT INTO A (s, t) VALUES (8, 16);
INSERT INTO A (s, t) VALUES (8, 19);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 13);
INSERT INTO B (s, t) VALUES (9, 19);
INSERT INTO A (s, t) VALUES (10, 18);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 5);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO B (s, t) VALUES (12, 1);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 15);
INSERT INTO A (s, t) VALUES (13, 1);
INSERT INTO B (s, t) VALUES (13, 10);
INSERT INTO A (s, t) VALUES (13, 16);
INSERT INTO A (s, t) VALUES (14, 0);
INSERT INTO B (s, t) VALUES (14, 5);
INSERT INTO B (s, t) VALUES (14, 17);
INSERT INTO A (s, t) VALUES (14, 19);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 9);
INSERT INTO A (s, t) VALUES (15, 14);
INSERT INTO B (s, t) VALUES (15, 19);
INSERT INTO B (s, t) VALUES (16, 0);
INSERT INTO A (s, t) VALUES (16, 6);
INSERT INTO A (s, t) VALUES (16, 15);
INSERT INTO B (s, t) VALUES (17, 0);
INSERT INTO A (s, t) VALUES (17, 3);
INSERT INTO A (s, t) VALUES (17, 7);
INSERT INTO A (s, t) VALUES (17, 9);
INSERT INTO B (s, t) VALUES (17, 10);
INSERT INTO B (s, t) VALUES (17, 13);
INSERT INTO B (s, t) VALUES (17, 18);
INSERT INTO A (s, t) VALUES (18, 9);
INSERT INTO B (s, t) VALUES (19, 7);
INSERT INTO B (s, t) VALUES (19, 14);
INSERT INTO B (s, t) VALUES (19, 18);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
20,0.2,41999,true,15:00:47
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO A (s, t) VALUES (0, 17);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 12);
INSERT INTO A (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (1, 19);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (2, 11);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 15);
INSERT INTO B (s, t) VALUES (3, 19);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (4, 13);
INSERT INTO A (s, t) VALUES (4, 14);
INSERT INTO A (s, t) VALUES (4, 19);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 13);
INSERT INTO A (s, t) VALUES (5, 15);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (6, 13);
INSERT INTO A (s, t) VALUES (6, 15);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 16);
INSERT INTO A (s, t) VALUES (7, 19);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 14);
INSERT INTO B (s, t) VALUES (8, 15);
INSERT INTO A (s, t) VALUES (8, 16);
INSERT INTO A (s, t) VALUES (8, 19);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 13);
INSERT INTO B (s, t) VALUES (9, 19);
INSERT INTO A (s, t) VALUES (10, 18);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 5);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO B (s, t) VALUES (12, 1);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 15);
INSERT INTO A (s, t) VALUES (13, 1);
INSERT INTO B (s, t) VALUES (13, 10);
INSERT INTO A (s, t) VALUES (13, 16);
INSERT INTO A (s, t) VALUES (14, 0);
INSERT INTO B (s, t) VALUES (14, 5);
INSERT INTO B (s, t) VALUES (14, 17);
INSERT INTO A (s, t) VALUES (14, 19);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 9);
INSERT INTO A (s, t) VALUES (15, 14);
INSERT INTO B (s, t) VALUES (15, 19);
INSERT INTO B (s, t) VALUES (16, 0);
INSERT INTO A (s, t) VALUES (16, 6);
INSERT INTO A (s, t) VALUES (16, 15);
INSERT INTO B (s, t) VALUES (17, 0);
INSERT INTO A (s, t) VALUES (17, 3);
INSERT INTO A (s, t) VALUES (17, 7);
INSERT INTO A (s, t) VALUES (17, 9);
INSERT INTO B (s, t) VALUES (17, 10);
INSERT INTO B (s, t) VALUES (17, 13);
INSERT INTO B (s, t) VALUES (17, 18);
INSERT INTO A (s, t) VALUES (18, 9);
INSERT INTO B (s, t) VALUES (19, 7);
INSERT INTO B (s, t) VALUES (19, 14);
INSERT INTO B (s, t) VALUES (19, 18);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
20,0.2,41844,true,15:01:29
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO A (s, t) VALUES (0, 17);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 12);
INSERT INTO A (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (1, 19);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (2, 11);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 15);
INSERT INTO B (s, t) VALUES (3, 19);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (4, 13);
INSERT INTO A (s, t) VALUES (4, 14);
INSERT INTO A (s, t) VALUES (4, 19);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 13);
INSERT INTO A (s, t) VALUES (5, 15);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (6, 13);
INSERT INTO A (s, t) VALUES (6, 15);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 16);
INSERT INTO A (s, t) VALUES (7, 19);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 14);
INSERT INTO B (s, t) VALUES (8, 15);
INSERT INTO A (s, t) VALUES (8, 16);
INSERT INTO A (s, t) VALUES (8, 19);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 13);
INSERT INTO B (s, t) VALUES (9, 19);
INSERT INTO A (s, t) VALUES (10, 18);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 5);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO B (s, t) VALUES (12, 1);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 15);
INSERT INTO A (s, t) VALUES (13, 1);
INSERT INTO B (s, t) VALUES (13, 10);
INSERT INTO A (s, t) VALUES (13, 16);
INSERT INTO A (s, t) VALUES (14, 0);
INSERT INTO B (s, t) VALUES (14, 5);
INSERT INTO B (s, t) VALUES (14, 17);
INSERT INTO A (s, t) VALUES (14, 19);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 9);
INSERT INTO A (s, t) VALUES (15, 14);
INSERT INTO B (s, t) VALUES (15, 19);
INSERT INTO B (s, t) VALUES (16, 0);
INSERT INTO A (s, t) VALUES (16, 6);
INSERT INTO A (s, t) VALUES (16, 15);
INSERT INTO B (s, t) VALUES (17, 0);
INSERT INTO A (s, t) VALUES (17, 3);
INSERT INTO A (s, t) VALUES (17, 7);
INSERT INTO A (s, t) VALUES (17, 9);
INSERT INTO B (s, t) VALUES (17, 10);
INSERT INTO B (s, t) VALUES (17, 13);
INSERT INTO B (s, t) VALUES (17, 18);
INSERT INTO A (s, t) VALUES (18, 9);
INSERT INTO B (s, t) VALUES (19, 7);
INSERT INTO B (s, t) VALUES (19, 14);
INSERT INTO B (s, t) VALUES (19, 18);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
20,0.2,41946,true,15:02:11
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 6);
INSERT INTO B (s, t) VALUES (0, 11);
INSERT INTO A (s, t) VALUES (0, 17);
INSERT INTO B (s, t) VALUES (1, 6);
INSERT INTO A (s, t) VALUES (1, 12);
INSERT INTO A (s, t) VALUES (1, 13);
INSERT INTO B (s, t) VALUES (1, 19);
INSERT INTO A (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 2);
INSERT INTO B (s, t) VALUES (2, 4);
INSERT INTO A (s, t) VALUES (2, 5);
INSERT INTO A (s, t) VALUES (2, 10);
INSERT INTO A (s, t) VALUES (2, 11);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (3, 2);
INSERT INTO A (s, t) VALUES (3, 15);
INSERT INTO B (s, t) VALUES (3, 19);
INSERT INTO A (s, t) VALUES (4, 9);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (4, 13);
INSERT INTO A (s, t) VALUES (4, 14);
INSERT INTO A (s, t) VALUES (4, 19);
INSERT INTO B (s, t) VALUES (5, 7);
INSERT INTO A (s, t) VALUES (5, 8);
INSERT INTO A (s, t) VALUES (5, 13);
INSERT INTO A (s, t) VALUES (5, 15);
INSERT INTO B (s, t) VALUES (6, 0);
INSERT INTO B (s, t) VALUES (6, 1);
INSERT INTO B (s, t) VALUES (6, 3);
INSERT INTO A (s, t) VALUES (6, 7);
INSERT INTO A (s, t) VALUES (6, 9);
INSERT INTO A (s, t) VALUES (6, 10);
INSERT INTO B (s, t) VALUES (6, 13);
INSERT INTO A (s, t) VALUES (6, 15);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 2);
INSERT INTO A (s, t) VALUES (7, 16);
INSERT INTO A (s, t) VALUES (7, 19);
INSERT INTO A (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 8);
INSERT INTO B (s, t) VALUES (8, 14);
INSERT INTO B (s, t) VALUES (8, 15);
INSERT INTO A (s, t) VALUES (8, 16);
INSERT INTO A (s, t) VALUES (8, 19);
INSERT INTO A (s, t) VALUES (9, 9);
INSERT INTO B (s, t) VALUES (9, 10);
INSERT INTO B (s, t) VALUES (9, 13);
INSERT INTO B (s, t) VALUES (9, 19);
INSERT INTO A (s, t) VALUES (10, 18);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO A (s, t) VALUES (11, 5);
INSERT INTO A (s, t) VALUES (11, 7);
INSERT INTO B (s, t) VALUES (11, 9);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO B (s, t) VALUES (12, 1);
INSERT INTO A (s, t) VALUES (12, 2);
INSERT INTO B (s, t) VALUES (12, 15);
INSERT INTO A (s, t) VALUES (13, 1);
INSERT INTO B (s, t) VALUES (13, 10);
INSERT INTO A (s, t) VALUES (13, 16);
INSERT INTO A (s, t) VALUES (14, 0);
INSERT INTO B (s, t) VALUES (14, 5);
INSERT INTO B (s, t) VALUES (14, 17);
INSERT INTO A (s, t) VALUES (14, 19);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 9);
INSERT INTO A (s, t) VALUES (15, 14);
INSERT INTO B (s, t) VALUES (15, 19);
INSERT INTO B (s, t) VALUES (16, 0);
INSERT INTO A (s, t) VALUES (16, 6);
INSERT INTO A (s, t) VALUES (16, 15);
INSERT INTO B (s, t) VALUES (17, 0);
INSERT INTO A (s, t) VALUES (17, 3);
INSERT INTO A (s, t) VALUES (17, 7);
INSERT INTO A (s, t) VALUES (17, 9);
INSERT INTO B (s, t) VALUES (17, 10);
INSERT INTO B (s, t) VALUES (17, 13);
INSERT INTO B (s, t) VALUES (17, 18);
INSERT INTO A (s, t) VALUES (18, 9);
INSERT INTO B (s, t) VALUES (19, 7);
INSERT INTO B (s, t) VALUES (19, 14);
INSERT INTO B (s, t) VALUES (19, 18);
INSERT INTO StartLabel VALUES (6)
INSERT INTO EndLabel VALUES (1)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
20,0.2,timeout,false,15:12:11
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 14);
INSERT INTO A (s, t) VALUES (0, 16);
INSERT INTO B (s, t) VALUES (0, 18);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 11);
INSERT INTO A (s, t) VALUES (1, 12);
INSERT INTO A (s, t) VALUES (1, 16);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (2, 18);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO A (s, t) VALUES (3, 17);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (5, 14);
INSERT INTO B (s, t) VALUES (5, 17);
INSERT INTO B (s, t) VALUES (5, 19);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 12);
INSERT INTO A (s, t) VALUES (6, 13);
INSERT INTO B (s, t) VALUES (6, 18);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (7, 18);
INSERT INTO B (s, t) VALUES (7, 19);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (10, 10);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 10);
INSERT INTO A (s, t) VALUES (11, 16);
INSERT INTO B (s, t) VALUES (11, 17);
INSERT INTO B (s, t) VALUES (11, 18);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 12);
INSERT INTO A (s, t) VALUES (12, 13);
INSERT INTO B (s, t) VALUES (13, 7);
INSERT INTO A (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (13, 11);
INSERT INTO A (s, t) VALUES (14, 0);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 11);
INSERT INTO B (s, t) VALUES (14, 12);
INSERT INTO A (s, t) VALUES (14, 18);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO B (s, t) VALUES (15, 4);
INSERT INTO A (s, t) VALUES (15, 6);
INSERT INTO A (s, t) VALUES (15, 10);
INSERT INTO A (s, t) VALUES (16, 0);
INSERT INTO B (s, t) VALUES (16, 4);
INSERT INTO B (s, t) VALUES (16, 7);
INSERT INTO A (s, t) VALUES (16, 11);
INSERT INTO B (s, t) VALUES (16, 17);
INSERT INTO A (s, t) VALUES (16, 19);
INSERT INTO B (s, t) VALUES (17, 0);
INSERT INTO B (s, t) VALUES (17, 6);
INSERT INTO A (s, t) VALUES (17, 9);
INSERT INTO B (s, t) VALUES (17, 11);
INSERT INTO B (s, t) VALUES (17, 12);
INSERT INTO B (s, t) VALUES (17, 17);
INSERT INTO A (s, t) VALUES (17, 18);
INSERT INTO B (s, t) VALUES (18, 7);
INSERT INTO B (s, t) VALUES (18, 19);
INSERT INTO B (s, t) VALUES (19, 2);
INSERT INTO B (s, t) VALUES (19, 10);
INSERT INTO A (s, t) VALUES (19, 11);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (13)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
20,0.2,timeout,false,15:17:11
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 14);
INSERT INTO A (s, t) VALUES (0, 16);
INSERT INTO B (s, t) VALUES (0, 18);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 11);
INSERT INTO A (s, t) VALUES (1, 12);
INSERT INTO A (s, t) VALUES (1, 16);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (2, 18);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO A (s, t) VALUES (3, 17);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (5, 14);
INSERT INTO B (s, t) VALUES (5, 17);
INSERT INTO B (s, t) VALUES (5, 19);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 12);
INSERT INTO A (s, t) VALUES (6, 13);
INSERT INTO B (s, t) VALUES (6, 18);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (7, 18);
INSERT INTO B (s, t) VALUES (7, 19);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (10, 10);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 10);
INSERT INTO A (s, t) VALUES (11, 16);
INSERT INTO B (s, t) VALUES (11, 17);
INSERT INTO B (s, t) VALUES (11, 18);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 12);
INSERT INTO A (s, t) VALUES (12, 13);
INSERT INTO B (s, t) VALUES (13, 7);
INSERT INTO A (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (13, 11);
INSERT INTO A (s, t) VALUES (14, 0);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 11);
INSERT INTO B (s, t) VALUES (14, 12);
INSERT INTO A (s, t) VALUES (14, 18);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO B (s, t) VALUES (15, 4);
INSERT INTO A (s, t) VALUES (15, 6);
INSERT INTO A (s, t) VALUES (15, 10);
INSERT INTO A (s, t) VALUES (16, 0);
INSERT INTO B (s, t) VALUES (16, 4);
INSERT INTO B (s, t) VALUES (16, 7);
INSERT INTO A (s, t) VALUES (16, 11);
INSERT INTO B (s, t) VALUES (16, 17);
INSERT INTO A (s, t) VALUES (16, 19);
INSERT INTO B (s, t) VALUES (17, 0);
INSERT INTO B (s, t) VALUES (17, 6);
INSERT INTO A (s, t) VALUES (17, 9);
INSERT INTO B (s, t) VALUES (17, 11);
INSERT INTO B (s, t) VALUES (17, 12);
INSERT INTO B (s, t) VALUES (17, 17);
INSERT INTO A (s, t) VALUES (17, 18);
INSERT INTO B (s, t) VALUES (18, 7);
INSERT INTO B (s, t) VALUES (18, 19);
INSERT INTO B (s, t) VALUES (19, 2);
INSERT INTO B (s, t) VALUES (19, 10);
INSERT INTO A (s, t) VALUES (19, 11);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (13)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
20,0.2,timeout,false,15:22:11
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 14);
INSERT INTO A (s, t) VALUES (0, 16);
INSERT INTO B (s, t) VALUES (0, 18);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 11);
INSERT INTO A (s, t) VALUES (1, 12);
INSERT INTO A (s, t) VALUES (1, 16);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (2, 18);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO A (s, t) VALUES (3, 17);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (5, 14);
INSERT INTO B (s, t) VALUES (5, 17);
INSERT INTO B (s, t) VALUES (5, 19);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 12);
INSERT INTO A (s, t) VALUES (6, 13);
INSERT INTO B (s, t) VALUES (6, 18);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (7, 18);
INSERT INTO B (s, t) VALUES (7, 19);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (10, 10);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 10);
INSERT INTO A (s, t) VALUES (11, 16);
INSERT INTO B (s, t) VALUES (11, 17);
INSERT INTO B (s, t) VALUES (11, 18);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 12);
INSERT INTO A (s, t) VALUES (12, 13);
INSERT INTO B (s, t) VALUES (13, 7);
INSERT INTO A (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (13, 11);
INSERT INTO A (s, t) VALUES (14, 0);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 11);
INSERT INTO B (s, t) VALUES (14, 12);
INSERT INTO A (s, t) VALUES (14, 18);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO B (s, t) VALUES (15, 4);
INSERT INTO A (s, t) VALUES (15, 6);
INSERT INTO A (s, t) VALUES (15, 10);
INSERT INTO A (s, t) VALUES (16, 0);
INSERT INTO B (s, t) VALUES (16, 4);
INSERT INTO B (s, t) VALUES (16, 7);
INSERT INTO A (s, t) VALUES (16, 11);
INSERT INTO B (s, t) VALUES (16, 17);
INSERT INTO A (s, t) VALUES (16, 19);
INSERT INTO B (s, t) VALUES (17, 0);
INSERT INTO B (s, t) VALUES (17, 6);
INSERT INTO A (s, t) VALUES (17, 9);
INSERT INTO B (s, t) VALUES (17, 11);
INSERT INTO B (s, t) VALUES (17, 12);
INSERT INTO B (s, t) VALUES (17, 17);
INSERT INTO A (s, t) VALUES (17, 18);
INSERT INTO B (s, t) VALUES (18, 7);
INSERT INTO B (s, t) VALUES (18, 19);
INSERT INTO B (s, t) VALUES (19, 2);
INSERT INTO B (s, t) VALUES (19, 10);
INSERT INTO A (s, t) VALUES (19, 11);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (13)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
20,0.2,timeout,false,15:27:11
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 0);
INSERT INTO A (s, t) VALUES (0, 1);
INSERT INTO A (s, t) VALUES (0, 5);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 14);
INSERT INTO A (s, t) VALUES (0, 16);
INSERT INTO B (s, t) VALUES (0, 18);
INSERT INTO B (s, t) VALUES (1, 3);
INSERT INTO B (s, t) VALUES (1, 7);
INSERT INTO B (s, t) VALUES (1, 11);
INSERT INTO A (s, t) VALUES (1, 12);
INSERT INTO A (s, t) VALUES (1, 16);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (2, 18);
INSERT INTO B (s, t) VALUES (3, 3);
INSERT INTO B (s, t) VALUES (3, 10);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO A (s, t) VALUES (3, 17);
INSERT INTO A (s, t) VALUES (4, 3);
INSERT INTO B (s, t) VALUES (4, 5);
INSERT INTO B (s, t) VALUES (4, 11);
INSERT INTO A (s, t) VALUES (4, 13);
INSERT INTO B (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 11);
INSERT INTO B (s, t) VALUES (5, 14);
INSERT INTO B (s, t) VALUES (5, 17);
INSERT INTO B (s, t) VALUES (5, 19);
INSERT INTO B (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 12);
INSERT INTO A (s, t) VALUES (6, 13);
INSERT INTO B (s, t) VALUES (6, 18);
INSERT INTO B (s, t) VALUES (7, 1);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 11);
INSERT INTO A (s, t) VALUES (7, 18);
INSERT INTO B (s, t) VALUES (7, 19);
INSERT INTO A (s, t) VALUES (9, 3);
INSERT INTO B (s, t) VALUES (9, 4);
INSERT INTO A (s, t) VALUES (9, 6);
INSERT INTO A (s, t) VALUES (10, 3);
INSERT INTO B (s, t) VALUES (10, 7);
INSERT INTO A (s, t) VALUES (10, 10);
INSERT INTO A (s, t) VALUES (11, 3);
INSERT INTO A (s, t) VALUES (11, 5);
INSERT INTO B (s, t) VALUES (11, 10);
INSERT INTO A (s, t) VALUES (11, 16);
INSERT INTO B (s, t) VALUES (11, 17);
INSERT INTO B (s, t) VALUES (11, 18);
INSERT INTO B (s, t) VALUES (12, 0);
INSERT INTO A (s, t) VALUES (12, 1);
INSERT INTO B (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 7);
INSERT INTO B (s, t) VALUES (12, 12);
INSERT INTO A (s, t) VALUES (12, 13);
INSERT INTO B (s, t) VALUES (13, 7);
INSERT INTO A (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (13, 11);
INSERT INTO A (s, t) VALUES (14, 0);
INSERT INTO B (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 11);
INSERT INTO B (s, t) VALUES (14, 12);
INSERT INTO A (s, t) VALUES (14, 18);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO B (s, t) VALUES (15, 4);
INSERT INTO A (s, t) VALUES (15, 6);
INSERT INTO A (s, t) VALUES (15, 10);
INSERT INTO A (s, t) VALUES (16, 0);
INSERT INTO B (s, t) VALUES (16, 4);
INSERT INTO B (s, t) VALUES (16, 7);
INSERT INTO A (s, t) VALUES (16, 11);
INSERT INTO B (s, t) VALUES (16, 17);
INSERT INTO A (s, t) VALUES (16, 19);
INSERT INTO B (s, t) VALUES (17, 0);
INSERT INTO B (s, t) VALUES (17, 6);
INSERT INTO A (s, t) VALUES (17, 9);
INSERT INTO B (s, t) VALUES (17, 11);
INSERT INTO B (s, t) VALUES (17, 12);
INSERT INTO B (s, t) VALUES (17, 17);
INSERT INTO A (s, t) VALUES (17, 18);
INSERT INTO B (s, t) VALUES (18, 7);
INSERT INTO B (s, t) VALUES (18, 19);
INSERT INTO B (s, t) VALUES (19, 2);
INSERT INTO B (s, t) VALUES (19, 10);
INSERT INTO A (s, t) VALUES (19, 11);
INSERT INTO StartLabel VALUES (10)
INSERT INTO EndLabel VALUES (13)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
20,0.2,1521,false,15:27:14
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 15);
INSERT INTO B (s, t) VALUES (1, 18);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 11);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (2, 14);
INSERT INTO A (s, t) VALUES (2, 15);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO A (s, t) VALUES (3, 14);
INSERT INTO B (s, t) VALUES (3, 15);
INSERT INTO A (s, t) VALUES (3, 19);
INSERT INTO B (s, t) VALUES (4, 17);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 11);
INSERT INTO A (s, t) VALUES (5, 15);
INSERT INTO B (s, t) VALUES (5, 19);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (6, 16);
INSERT INTO A (s, t) VALUES (6, 18);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 15);
INSERT INTO B (s, t) VALUES (8, 17);
INSERT INTO B (s, t) VALUES (8, 18);
INSERT INTO A (s, t) VALUES (8, 19);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO B (s, t) VALUES (11, 13);
INSERT INTO B (s, t) VALUES (11, 14);
INSERT INTO A (s, t) VALUES (11, 18);
INSERT INTO A (s, t) VALUES (12, 6);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO B (s, t) VALUES (12, 15);
INSERT INTO A (s, t) VALUES (13, 6);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (13, 12);
INSERT INTO A (s, t) VALUES (15, 14);
INSERT INTO B (s, t) VALUES (16, 1);
INSERT INTO B (s, t) VALUES (16, 3);
INSERT INTO B (s, t) VALUES (16, 7);
INSERT INTO A (s, t) VALUES (16, 11);
INSERT INTO B (s, t) VALUES (16, 17);
INSERT INTO B (s, t) VALUES (17, 9);
INSERT INTO A (s, t) VALUES (18, 3);
INSERT INTO B (s, t) VALUES (18, 8);
INSERT INTO A (s, t) VALUES (18, 11);
INSERT INTO B (s, t) VALUES (18, 18);
INSERT INTO A (s, t) VALUES (19, 6);
INSERT INTO A (s, t) VALUES (19, 10);
INSERT INTO A (s, t) VALUES (19, 11);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (13)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
20,0.2,1540,false,15:27:16
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 15);
INSERT INTO B (s, t) VALUES (1, 18);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 11);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (2, 14);
INSERT INTO A (s, t) VALUES (2, 15);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO A (s, t) VALUES (3, 14);
INSERT INTO B (s, t) VALUES (3, 15);
INSERT INTO A (s, t) VALUES (3, 19);
INSERT INTO B (s, t) VALUES (4, 17);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 11);
INSERT INTO A (s, t) VALUES (5, 15);
INSERT INTO B (s, t) VALUES (5, 19);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (6, 16);
INSERT INTO A (s, t) VALUES (6, 18);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 15);
INSERT INTO B (s, t) VALUES (8, 17);
INSERT INTO B (s, t) VALUES (8, 18);
INSERT INTO A (s, t) VALUES (8, 19);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO B (s, t) VALUES (11, 13);
INSERT INTO B (s, t) VALUES (11, 14);
INSERT INTO A (s, t) VALUES (11, 18);
INSERT INTO A (s, t) VALUES (12, 6);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO B (s, t) VALUES (12, 15);
INSERT INTO A (s, t) VALUES (13, 6);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (13, 12);
INSERT INTO A (s, t) VALUES (15, 14);
INSERT INTO B (s, t) VALUES (16, 1);
INSERT INTO B (s, t) VALUES (16, 3);
INSERT INTO B (s, t) VALUES (16, 7);
INSERT INTO A (s, t) VALUES (16, 11);
INSERT INTO B (s, t) VALUES (16, 17);
INSERT INTO B (s, t) VALUES (17, 9);
INSERT INTO A (s, t) VALUES (18, 3);
INSERT INTO B (s, t) VALUES (18, 8);
INSERT INTO A (s, t) VALUES (18, 11);
INSERT INTO B (s, t) VALUES (18, 18);
INSERT INTO A (s, t) VALUES (19, 6);
INSERT INTO A (s, t) VALUES (19, 10);
INSERT INTO A (s, t) VALUES (19, 11);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (13)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
20,0.2,1540,false,15:27:17
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 15);
INSERT INTO B (s, t) VALUES (1, 18);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 11);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (2, 14);
INSERT INTO A (s, t) VALUES (2, 15);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO A (s, t) VALUES (3, 14);
INSERT INTO B (s, t) VALUES (3, 15);
INSERT INTO A (s, t) VALUES (3, 19);
INSERT INTO B (s, t) VALUES (4, 17);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 11);
INSERT INTO A (s, t) VALUES (5, 15);
INSERT INTO B (s, t) VALUES (5, 19);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (6, 16);
INSERT INTO A (s, t) VALUES (6, 18);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 15);
INSERT INTO B (s, t) VALUES (8, 17);
INSERT INTO B (s, t) VALUES (8, 18);
INSERT INTO A (s, t) VALUES (8, 19);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO B (s, t) VALUES (11, 13);
INSERT INTO B (s, t) VALUES (11, 14);
INSERT INTO A (s, t) VALUES (11, 18);
INSERT INTO A (s, t) VALUES (12, 6);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO B (s, t) VALUES (12, 15);
INSERT INTO A (s, t) VALUES (13, 6);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (13, 12);
INSERT INTO A (s, t) VALUES (15, 14);
INSERT INTO B (s, t) VALUES (16, 1);
INSERT INTO B (s, t) VALUES (16, 3);
INSERT INTO B (s, t) VALUES (16, 7);
INSERT INTO A (s, t) VALUES (16, 11);
INSERT INTO B (s, t) VALUES (16, 17);
INSERT INTO B (s, t) VALUES (17, 9);
INSERT INTO A (s, t) VALUES (18, 3);
INSERT INTO B (s, t) VALUES (18, 8);
INSERT INTO A (s, t) VALUES (18, 11);
INSERT INTO B (s, t) VALUES (18, 18);
INSERT INTO A (s, t) VALUES (19, 6);
INSERT INTO A (s, t) VALUES (19, 10);
INSERT INTO A (s, t) VALUES (19, 11);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (13)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
20,0.2,1535,false,15:27:19
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO B (s, t) VALUES (0, 2);
INSERT INTO A (s, t) VALUES (0, 9);
INSERT INTO B (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (0, 13);
INSERT INTO B (s, t) VALUES (1, 9);
INSERT INTO B (s, t) VALUES (1, 15);
INSERT INTO B (s, t) VALUES (1, 18);
INSERT INTO B (s, t) VALUES (2, 0);
INSERT INTO B (s, t) VALUES (2, 11);
INSERT INTO B (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (2, 14);
INSERT INTO A (s, t) VALUES (2, 15);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO B (s, t) VALUES (3, 6);
INSERT INTO A (s, t) VALUES (3, 12);
INSERT INTO A (s, t) VALUES (3, 14);
INSERT INTO B (s, t) VALUES (3, 15);
INSERT INTO A (s, t) VALUES (3, 19);
INSERT INTO B (s, t) VALUES (4, 17);
INSERT INTO A (s, t) VALUES (5, 5);
INSERT INTO B (s, t) VALUES (5, 6);
INSERT INTO A (s, t) VALUES (5, 9);
INSERT INTO A (s, t) VALUES (5, 11);
INSERT INTO A (s, t) VALUES (5, 15);
INSERT INTO B (s, t) VALUES (5, 19);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 11);
INSERT INTO A (s, t) VALUES (6, 16);
INSERT INTO A (s, t) VALUES (6, 18);
INSERT INTO A (s, t) VALUES (7, 0);
INSERT INTO A (s, t) VALUES (7, 5);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (8, 1);
INSERT INTO B (s, t) VALUES (8, 3);
INSERT INTO B (s, t) VALUES (8, 15);
INSERT INTO B (s, t) VALUES (8, 17);
INSERT INTO B (s, t) VALUES (8, 18);
INSERT INTO A (s, t) VALUES (8, 19);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO B (s, t) VALUES (9, 7);
INSERT INTO B (s, t) VALUES (11, 13);
INSERT INTO B (s, t) VALUES (11, 14);
INSERT INTO A (s, t) VALUES (11, 18);
INSERT INTO A (s, t) VALUES (12, 6);
INSERT INTO B (s, t) VALUES (12, 13);
INSERT INTO B (s, t) VALUES (12, 15);
INSERT INTO A (s, t) VALUES (13, 6);
INSERT INTO B (s, t) VALUES (13, 8);
INSERT INTO A (s, t) VALUES (13, 12);
INSERT INTO A (s, t) VALUES (15, 14);
INSERT INTO B (s, t) VALUES (16, 1);
INSERT INTO B (s, t) VALUES (16, 3);
INSERT INTO B (s, t) VALUES (16, 7);
INSERT INTO A (s, t) VALUES (16, 11);
INSERT INTO B (s, t) VALUES (16, 17);
INSERT INTO B (s, t) VALUES (17, 9);
INSERT INTO A (s, t) VALUES (18, 3);
INSERT INTO B (s, t) VALUES (18, 8);
INSERT INTO A (s, t) VALUES (18, 11);
INSERT INTO B (s, t) VALUES (18, 18);
INSERT INTO A (s, t) VALUES (19, 6);
INSERT INTO A (s, t) VALUES (19, 10);
INSERT INTO A (s, t) VALUES (19, 11);
INSERT INTO StartLabel VALUES (8)
INSERT INTO EndLabel VALUES (13)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
20,0.2,timeout,false,15:37:19
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (1, 15);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (2, 16);
INSERT INTO B (s, t) VALUES (2, 19);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 11);
INSERT INTO B (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 15);
INSERT INTO B (s, t) VALUES (3, 16);
INSERT INTO A (s, t) VALUES (3, 19);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 14);
INSERT INTO B (s, t) VALUES (5, 14);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 16);
INSERT INTO B (s, t) VALUES (6, 18);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 13);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 12);
INSERT INTO B (s, t) VALUES (8, 18);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 16);
INSERT INTO A (s, t) VALUES (9, 19);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 2);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO B (s, t) VALUES (11, 17);
INSERT INTO A (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 15);
INSERT INTO B (s, t) VALUES (12, 19);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 2);
INSERT INTO A (s, t) VALUES (13, 12);
INSERT INTO B (s, t) VALUES (14, 3);
INSERT INTO A (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 6);
INSERT INTO B (s, t) VALUES (14, 12);
INSERT INTO A (s, t) VALUES (14, 18);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 1);
INSERT INTO A (s, t) VALUES (15, 8);
INSERT INTO A (s, t) VALUES (15, 10);
INSERT INTO A (s, t) VALUES (15, 12);
INSERT INTO A (s, t) VALUES (15, 16);
INSERT INTO B (s, t) VALUES (16, 3);
INSERT INTO A (s, t) VALUES (16, 7);
INSERT INTO A (s, t) VALUES (16, 19);
INSERT INTO A (s, t) VALUES (17, 6);
INSERT INTO A (s, t) VALUES (17, 11);
INSERT INTO A (s, t) VALUES (17, 12);
INSERT INTO A (s, t) VALUES (17, 16);
INSERT INTO B (s, t) VALUES (18, 3);
INSERT INTO A (s, t) VALUES (18, 7);
INSERT INTO B (s, t) VALUES (18, 12);
INSERT INTO A (s, t) VALUES (19, 3);
INSERT INTO B (s, t) VALUES (19, 5);
INSERT INTO B (s, t) VALUES (19, 11);
INSERT INTO B (s, t) VALUES (19, 12);
INSERT INTO B (s, t) VALUES (19, 13);
INSERT INTO B (s, t) VALUES (19, 15);
INSERT INTO A (s, t) VALUES (19, 17);
INSERT INTO A (s, t) VALUES (19, 18);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
20,0.2,timeout,false,15:42:19
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (1, 15);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (2, 16);
INSERT INTO B (s, t) VALUES (2, 19);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 11);
INSERT INTO B (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 15);
INSERT INTO B (s, t) VALUES (3, 16);
INSERT INTO A (s, t) VALUES (3, 19);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 14);
INSERT INTO B (s, t) VALUES (5, 14);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 16);
INSERT INTO B (s, t) VALUES (6, 18);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 13);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 12);
INSERT INTO B (s, t) VALUES (8, 18);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 16);
INSERT INTO A (s, t) VALUES (9, 19);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 2);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO B (s, t) VALUES (11, 17);
INSERT INTO A (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 15);
INSERT INTO B (s, t) VALUES (12, 19);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 2);
INSERT INTO A (s, t) VALUES (13, 12);
INSERT INTO B (s, t) VALUES (14, 3);
INSERT INTO A (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 6);
INSERT INTO B (s, t) VALUES (14, 12);
INSERT INTO A (s, t) VALUES (14, 18);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 1);
INSERT INTO A (s, t) VALUES (15, 8);
INSERT INTO A (s, t) VALUES (15, 10);
INSERT INTO A (s, t) VALUES (15, 12);
INSERT INTO A (s, t) VALUES (15, 16);
INSERT INTO B (s, t) VALUES (16, 3);
INSERT INTO A (s, t) VALUES (16, 7);
INSERT INTO A (s, t) VALUES (16, 19);
INSERT INTO A (s, t) VALUES (17, 6);
INSERT INTO A (s, t) VALUES (17, 11);
INSERT INTO A (s, t) VALUES (17, 12);
INSERT INTO A (s, t) VALUES (17, 16);
INSERT INTO B (s, t) VALUES (18, 3);
INSERT INTO A (s, t) VALUES (18, 7);
INSERT INTO B (s, t) VALUES (18, 12);
INSERT INTO A (s, t) VALUES (19, 3);
INSERT INTO B (s, t) VALUES (19, 5);
INSERT INTO B (s, t) VALUES (19, 11);
INSERT INTO B (s, t) VALUES (19, 12);
INSERT INTO B (s, t) VALUES (19, 13);
INSERT INTO B (s, t) VALUES (19, 15);
INSERT INTO A (s, t) VALUES (19, 17);
INSERT INTO A (s, t) VALUES (19, 18);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
20,0.2,timeout,false,15:47:19
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (1, 15);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (2, 16);
INSERT INTO B (s, t) VALUES (2, 19);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 11);
INSERT INTO B (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 15);
INSERT INTO B (s, t) VALUES (3, 16);
INSERT INTO A (s, t) VALUES (3, 19);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 14);
INSERT INTO B (s, t) VALUES (5, 14);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 16);
INSERT INTO B (s, t) VALUES (6, 18);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 13);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 12);
INSERT INTO B (s, t) VALUES (8, 18);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 16);
INSERT INTO A (s, t) VALUES (9, 19);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 2);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO B (s, t) VALUES (11, 17);
INSERT INTO A (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 15);
INSERT INTO B (s, t) VALUES (12, 19);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 2);
INSERT INTO A (s, t) VALUES (13, 12);
INSERT INTO B (s, t) VALUES (14, 3);
INSERT INTO A (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 6);
INSERT INTO B (s, t) VALUES (14, 12);
INSERT INTO A (s, t) VALUES (14, 18);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 1);
INSERT INTO A (s, t) VALUES (15, 8);
INSERT INTO A (s, t) VALUES (15, 10);
INSERT INTO A (s, t) VALUES (15, 12);
INSERT INTO A (s, t) VALUES (15, 16);
INSERT INTO B (s, t) VALUES (16, 3);
INSERT INTO A (s, t) VALUES (16, 7);
INSERT INTO A (s, t) VALUES (16, 19);
INSERT INTO A (s, t) VALUES (17, 6);
INSERT INTO A (s, t) VALUES (17, 11);
INSERT INTO A (s, t) VALUES (17, 12);
INSERT INTO A (s, t) VALUES (17, 16);
INSERT INTO B (s, t) VALUES (18, 3);
INSERT INTO A (s, t) VALUES (18, 7);
INSERT INTO B (s, t) VALUES (18, 12);
INSERT INTO A (s, t) VALUES (19, 3);
INSERT INTO B (s, t) VALUES (19, 5);
INSERT INTO B (s, t) VALUES (19, 11);
INSERT INTO B (s, t) VALUES (19, 12);
INSERT INTO B (s, t) VALUES (19, 13);
INSERT INTO B (s, t) VALUES (19, 15);
INSERT INTO A (s, t) VALUES (19, 17);
INSERT INTO A (s, t) VALUES (19, 18);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
20,0.2,timeout,false,15:52:19
DROP TABLE IF EXISTS A;
DROP TABLE IF EXISTS B;
DROP TABLE IF EXISTS StartLabel;
DROP TABLE IF EXISTS EndLabel;
CREATE TABLE A (id serial, s int, t int, primary key(s,t));
CREATE TABLE B (id serial, s int, t int, primary key(s,t));
CREATE TABLE StartLabel (node int);
CREATE TABLE EndLabel (node int);
INSERT INTO A (s, t) VALUES (0, 3);
INSERT INTO B (s, t) VALUES (0, 5);
INSERT INTO B (s, t) VALUES (0, 9);
INSERT INTO A (s, t) VALUES (0, 10);
INSERT INTO A (s, t) VALUES (0, 12);
INSERT INTO A (s, t) VALUES (1, 15);
INSERT INTO B (s, t) VALUES (2, 1);
INSERT INTO A (s, t) VALUES (2, 12);
INSERT INTO A (s, t) VALUES (2, 13);
INSERT INTO A (s, t) VALUES (2, 16);
INSERT INTO B (s, t) VALUES (2, 19);
INSERT INTO A (s, t) VALUES (3, 1);
INSERT INTO A (s, t) VALUES (3, 5);
INSERT INTO B (s, t) VALUES (3, 7);
INSERT INTO B (s, t) VALUES (3, 8);
INSERT INTO A (s, t) VALUES (3, 11);
INSERT INTO B (s, t) VALUES (3, 12);
INSERT INTO B (s, t) VALUES (3, 15);
INSERT INTO B (s, t) VALUES (3, 16);
INSERT INTO A (s, t) VALUES (3, 19);
INSERT INTO B (s, t) VALUES (4, 6);
INSERT INTO A (s, t) VALUES (4, 14);
INSERT INTO B (s, t) VALUES (5, 14);
INSERT INTO A (s, t) VALUES (6, 1);
INSERT INTO A (s, t) VALUES (6, 4);
INSERT INTO A (s, t) VALUES (6, 5);
INSERT INTO A (s, t) VALUES (6, 6);
INSERT INTO B (s, t) VALUES (6, 16);
INSERT INTO B (s, t) VALUES (6, 18);
INSERT INTO B (s, t) VALUES (7, 5);
INSERT INTO B (s, t) VALUES (7, 6);
INSERT INTO A (s, t) VALUES (7, 10);
INSERT INTO B (s, t) VALUES (7, 13);
INSERT INTO B (s, t) VALUES (8, 2);
INSERT INTO B (s, t) VALUES (8, 6);
INSERT INTO A (s, t) VALUES (8, 12);
INSERT INTO B (s, t) VALUES (8, 18);
INSERT INTO A (s, t) VALUES (9, 1);
INSERT INTO A (s, t) VALUES (9, 16);
INSERT INTO A (s, t) VALUES (9, 19);
INSERT INTO B (s, t) VALUES (10, 4);
INSERT INTO A (s, t) VALUES (10, 5);
INSERT INTO B (s, t) VALUES (10, 9);
INSERT INTO B (s, t) VALUES (11, 0);
INSERT INTO B (s, t) VALUES (11, 2);
INSERT INTO A (s, t) VALUES (11, 6);
INSERT INTO A (s, t) VALUES (11, 10);
INSERT INTO B (s, t) VALUES (11, 17);
INSERT INTO A (s, t) VALUES (12, 3);
INSERT INTO B (s, t) VALUES (12, 15);
INSERT INTO B (s, t) VALUES (12, 19);
INSERT INTO A (s, t) VALUES (13, 0);
INSERT INTO B (s, t) VALUES (13, 2);
INSERT INTO A (s, t) VALUES (13, 12);
INSERT INTO B (s, t) VALUES (14, 3);
INSERT INTO A (s, t) VALUES (14, 4);
INSERT INTO B (s, t) VALUES (14, 6);
INSERT INTO B (s, t) VALUES (14, 12);
INSERT INTO A (s, t) VALUES (14, 18);
INSERT INTO A (s, t) VALUES (15, 0);
INSERT INTO A (s, t) VALUES (15, 1);
INSERT INTO A (s, t) VALUES (15, 8);
INSERT INTO A (s, t) VALUES (15, 10);
INSERT INTO A (s, t) VALUES (15, 12);
INSERT INTO A (s, t) VALUES (15, 16);
INSERT INTO B (s, t) VALUES (16, 3);
INSERT INTO A (s, t) VALUES (16, 7);
INSERT INTO A (s, t) VALUES (16, 19);
INSERT INTO A (s, t) VALUES (17, 6);
INSERT INTO A (s, t) VALUES (17, 11);
INSERT INTO A (s, t) VALUES (17, 12);
INSERT INTO A (s, t) VALUES (17, 16);
INSERT INTO B (s, t) VALUES (18, 3);
INSERT INTO A (s, t) VALUES (18, 7);
INSERT INTO B (s, t) VALUES (18, 12);
INSERT INTO A (s, t) VALUES (19, 3);
INSERT INTO B (s, t) VALUES (19, 5);
INSERT INTO B (s, t) VALUES (19, 11);
INSERT INTO B (s, t) VALUES (19, 12);
INSERT INTO B (s, t) VALUES (19, 13);
INSERT INTO B (s, t) VALUES (19, 15);
INSERT INTO A (s, t) VALUES (19, 17);
INSERT INTO A (s, t) VALUES (19, 18);
INSERT INTO StartLabel VALUES (4)
INSERT INTO EndLabel VALUES (0)


explain analyze WITH RECURSIVE a_kleene_star AS (
		SELECT s, t, 0 AS depth, array[s,t] AS path,
				array[s||'.'|| t] AS edges FROM A
		UNION
		SELECT A.s, A.t, a_kleene_star.depth+1,
				a_kleene_star.path||A.t,
				a_kleene_star.edges ||
				concat(A.s||'.',A.t)
		FROM A , a_kleene_star
		WHERE A.s=a_kleene_star.t AND
		NOT concat(A.s||'.',A.t)=any(a_kleene_star.edges)
	)
	SELECT A1.s, A2.t
	FROM a_kleene_star A1, a_kleene_star A2, B, StartLabel, EndLabel
	WHERE A1.t=B.s AND B.t=A2.s AND A1.s=StartLabel.node AND
		A2.t=EndLabel.node AND NOT (A1.edges && A2.edges) 
	LIMIT 1;
------
